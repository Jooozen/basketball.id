<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Basketball Strategy Board</title>
  <style>
    :root {
      --court-color: #c8823c;
      --court-line: #ffffff;
      --offense-color: #2563eb;
      --defense-color: #dc2626;
      --ball-color: #f97316;
      --sidebar-bg: #1e293b;
      --sidebar-text: #f1f5f9;
      --btn-bg: #334155;
      --btn-hover: #475569;
      --btn-active: #2563eb;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0f172a; color: var(--sidebar-text);
      overflow: hidden; height: 100vh; height: 100dvh;
      display: flex; flex-direction: column; touch-action: none;
    }
    header {
      background: var(--sidebar-bg); padding: 6px 16px;
      display: flex; align-items: center; justify-content: space-between;
      border-bottom: 1px solid #334155; flex-shrink: 0;
    }
    header h1 { font-size: 16px; font-weight: 600; }
    header h1 span { color: var(--ball-color); }
    .main-layout { display: flex; flex: 1; overflow: hidden; }
    .sidebar {
      width: 200px; background: var(--sidebar-bg); padding: 12px;
      display: flex; flex-direction: column; gap: 12px;
      overflow-y: auto; border-right: 1px solid #334155; flex-shrink: 0;
    }
    .sidebar-section h3 {
      font-size: 10px; text-transform: uppercase; letter-spacing: 1px;
      color: #94a3b8; margin-bottom: 6px;
    }
    .tool-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; }
    .tool-btn {
      background: var(--btn-bg); border: 2px solid transparent;
      color: var(--sidebar-text); padding: 6px 4px; border-radius: 6px;
      cursor: pointer; font-size: 10px; text-align: center;
      transition: all 0.15s; display: flex; flex-direction: column;
      align-items: center; gap: 2px;
    }
    .tool-btn:hover { background: var(--btn-hover); }
    .tool-btn.active { border-color: var(--btn-active); background: rgba(37,99,235,0.2); }
    .tool-btn svg { width: 18px; height: 18px; }
    .action-btn {
      background: var(--btn-bg); border: none; color: var(--sidebar-text);
      padding: 7px 10px; border-radius: 6px; cursor: pointer; font-size: 11px;
      transition: all 0.15s; width: 100%; text-align: center;
    }
    .action-btn:hover { background: var(--btn-hover); }
    .action-btn.danger { color: #fca5a5; }
    .action-btn.danger:hover { background: rgba(220,38,38,0.3); }
    .formation-list { display: flex; flex-direction: column; gap: 3px; }
    .color-swatch {
      width: 20px; height: 20px; border-radius: 50%;
      border: 2px solid transparent; cursor: pointer; transition: border-color 0.15s;
    }
    .color-swatch.active { border-color: white; }
    .court-container {
      flex: 1; display: flex; align-items: center; justify-content: center;
      padding: 12px; position: relative; overflow: hidden;
    }
    .canvas-wrapper { position: relative; box-shadow: 0 4px 24px rgba(0,0,0,0.5); border-radius: 4px; }
    canvas { display: block; border-radius: 4px; }
    #courtCanvas { position: absolute; top: 0; left: 0; }
    #drawCanvas { position: absolute; top: 0; left: 0; }
    #interactionCanvas { position: relative; cursor: default; }
    .court-type-toggle { display: flex; gap: 4px; }
    .court-type-btn {
      flex: 1; background: var(--btn-bg); border: 2px solid transparent;
      color: var(--sidebar-text); padding: 5px; border-radius: 6px;
      cursor: pointer; font-size: 11px; text-align: center; transition: all 0.15s;
    }
    .court-type-btn:hover { background: var(--btn-hover); }
    .court-type-btn.active { border-color: var(--btn-active); background: rgba(37,99,235,0.2); }
    .undo-redo-btns { display: flex; gap: 4px; }
    .undo-redo-btns .action-btn { flex: 1; }
    .mobile-toolbar {
      display: none; background: var(--sidebar-bg);
      border-top: 1px solid #334155; flex-shrink: 0;
    }
    .mobile-toolbar-row {
      display: flex; overflow-x: auto; gap: 2px; padding: 6px 8px;
      -webkit-overflow-scrolling: touch;
    }
    .mobile-toolbar-row::-webkit-scrollbar { display: none; }
    .mobile-tool-btn {
      background: var(--btn-bg); border: 2px solid transparent;
      color: var(--sidebar-text); padding: 6px 10px; border-radius: 6px;
      cursor: pointer; font-size: 11px; white-space: nowrap; flex-shrink: 0;
    }
    .mobile-tool-btn:hover { background: var(--btn-hover); }
    .mobile-tool-btn.active { border-color: var(--btn-active); background: rgba(37,99,235,0.2); }
    .mobile-expand-panel {
      display: none; padding: 8px; gap: 6px; flex-wrap: wrap;
      border-top: 1px solid #334155; max-height: 200px; overflow-y: auto;
    }
    .mobile-expand-panel.open { display: flex; }
    .tactics-panel { display: flex; flex-direction: column; gap: 3px; }
    .tactics-btn {
      background: var(--btn-bg); border: 2px solid transparent;
      color: var(--sidebar-text); padding: 6px 8px; border-radius: 6px;
      cursor: pointer; font-size: 10px; text-align: left; transition: all 0.15s;
    }
    .tactics-btn:hover { background: var(--btn-hover); }
    .tactics-btn.active { border-color: #f59e0b; background: rgba(245,158,11,0.15); }
    .playback-controls { display: flex; gap: 3px; margin-top: 4px; }
    .playback-controls button {
      flex: 1; background: var(--btn-bg); border: none; color: var(--sidebar-text);
      padding: 6px 4px; border-radius: 6px; cursor: pointer; font-size: 11px;
      transition: all 0.15s;
    }
    .playback-controls button:hover { background: var(--btn-hover); }
    .playback-controls button.playing { background: #f59e0b; color: #000; }
    .step-info {
      background: rgba(0,0,0,0.3); border-radius: 6px; padding: 6px 8px;
      font-size: 10px; line-height: 1.4; margin-top: 4px; min-height: 40px;
    }
    .step-info .step-title { color: #f59e0b; font-weight: 600; font-size: 11px; }
    .step-info .step-desc { color: #cbd5e1; margin-top: 2px; }
    .step-info .step-condition { color: #f87171; font-style: italic; margin-top: 2px; font-size: 9px; }
    .tactic-explanation {
      background: rgba(245,158,11,0.1); border: 1px solid rgba(245,158,11,0.3);
      border-radius: 6px; padding: 6px 8px; font-size: 9px; line-height: 1.4;
      color: #fcd34d; margin-top: 4px;
    }
    @media (max-width: 768px) {
      header { padding: 4px 12px; }
      header h1 { font-size: 14px; }
      .sidebar { display: none; }
      .mobile-toolbar { display: block; }
      .court-container { padding: 8px; }
    }
  </style>
</head>
<body>
  <header>
    <h1><span>&#127936;</span> Basketball Strategy Board</h1>
    <div style="font-size:11px;color:#64748b;" class="header-subtitle">Drag &bull; Draw &bull; Plan</div>
  </header>
  <div class="main-layout">
    <div class="sidebar">
      <div class="sidebar-section">
        <h3>Court</h3>
        <div class="court-type-toggle">
          <button class="court-type-btn" data-court="full">Full</button>
          <button class="court-type-btn active" data-court="half">Half</button>
        </div>
      </div>
      <div class="sidebar-section">
        <h3>Tools</h3>
        <div class="tool-grid">
          <button class="tool-btn active" data-tool="cursor" title="Select & reposition players">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 9l-3 3 3 3"/><path d="M9 5l3-3 3 3"/><path d="M15 19l-3 3-3-3"/><path d="M19 9l3 3-3 3"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="12" y1="2" x2="12" y2="22"/></svg>
            Select
          </button>
          <button class="tool-btn" data-tool="dribble" title="Dribble: drag offense player with zigzag trail">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="4 20 8 14 12 18 16 10 20 4"/></svg>
            Dribble
          </button>
          <button class="tool-btn" data-tool="pmove" title="Move: drag offense player with line trail">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 17 Q12 8 19 12"/><polyline points="15 9 19 12 16 15"/></svg>
            Move
          </button>
          <button class="tool-btn" data-tool="screen" title="Screen: drag offense player with screen trail">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 18 Q12 10 18 8"/><line x1="15" y1="4" x2="21" y2="12" stroke-width="3"/></svg>
            Screen
          </button>
          <button class="tool-btn" data-tool="pass" title="Pass: drag ball with dotted trail">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-dasharray="4 3"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="14 7 19 12 14 17" stroke-dasharray="none"/></svg>
            Pass
          </button>
          <button class="tool-btn" data-tool="draw" title="Freehand draw">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/></svg>
            Draw
          </button>
          <button class="tool-btn" data-tool="eraser" title="Eraser">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 20H7L3 16l9-9 8 8-4 4z"/><line x1="7" y1="20" x2="16" y2="20"/></svg>
            Eraser
          </button>
          <button class="tool-btn" data-tool="text" title="Text label">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="4 7 4 4 20 4 20 7"/><line x1="12" y1="4" x2="12" y2="20"/><line x1="8" y1="20" x2="16" y2="20"/></svg>
            Text
          </button>
        </div>
      </div>
      <div class="sidebar-section">
        <h3>Pen Color</h3>
        <div style="display:flex;gap:5px;flex-wrap:wrap;">
          <div class="color-swatch active" data-color="#ffffff" style="background:#ffffff;"></div>
          <div class="color-swatch" data-color="#facc15" style="background:#facc15;"></div>
          <div class="color-swatch" data-color="#4ade80" style="background:#4ade80;"></div>
          <div class="color-swatch" data-color="#60a5fa" style="background:#60a5fa;"></div>
          <div class="color-swatch" data-color="#f87171" style="background:#f87171;"></div>
          <div class="color-swatch" data-color="#c084fc" style="background:#c084fc;"></div>
        </div>
        <h3 style="margin-top:8px;">Line Width</h3>
        <input type="range" style="width:100%;" id="lineWidth" min="1" max="8" value="3">
      </div>
      <div class="sidebar-section">
        <h3>Tactics Playbook</h3>
        <div class="tactics-panel" id="tacticsPanel"></div>
        <div class="playback-controls" id="playbackControls" style="display:none;">
          <button id="tacticPrev" title="Previous step">&#9664;&#9664;</button>
          <button id="tacticPlay" title="Play/Pause">&#9654; Play</button>
          <button id="tacticNext" title="Next step">&#9654;&#9654;</button>
          <button id="tacticStop" title="Stop & Reset">&#9632; Stop</button>
        </div>
        <div class="step-info" id="stepInfo" style="display:none;">
          <div class="step-title" id="stepTitle"></div>
          <div class="step-desc" id="stepDesc"></div>
          <div class="step-condition" id="stepCondition"></div>
        </div>
        <div class="tactic-explanation" id="tacticExplanation" style="display:none;"></div>
      </div>
      <div class="sidebar-section">
        <h3>Defense Formations</h3>
        <div class="formation-list">
          <button class="action-btn" data-formation="2-3">2-3 Zone</button>
          <button class="action-btn" data-formation="3-2">3-2 Zone</button>
          <button class="action-btn" data-formation="1-3-1">1-3-1 Zone</button>
          <button class="action-btn" data-formation="man-to-man">Man-to-Man</button>
          <button class="action-btn" data-formation="box-one">Box & One</button>
        </div>
      </div>
      <div class="sidebar-section">
        <h3>Mode</h3>
        <button class="action-btn" id="gameLikeBtn" style="border:2px solid transparent;transition:all 0.15s;">Game-like Mode</button>
      </div>
      <div class="sidebar-section">
        <h3>History</h3>
        <div class="undo-redo-btns">
          <button class="action-btn" id="undoBtn">Undo</button>
          <button class="action-btn" id="redoBtn">Redo</button>
        </div>
      </div>
      <div class="sidebar-section">
        <h3>Actions</h3>
        <button class="action-btn" id="clearDrawings">Clear Drawings</button>
        <button class="action-btn danger" id="resetAll" style="margin-top:3px;">Reset All</button>
        <button class="action-btn" id="exportBtn" style="margin-top:3px;">Export PNG</button>
      </div>
    </div>
    <div class="court-container">
      <div class="canvas-wrapper" id="canvasWrapper">
        <canvas id="courtCanvas"></canvas>
        <canvas id="drawCanvas"></canvas>
        <canvas id="interactionCanvas"></canvas>
      </div>
    </div>
  </div>
  <div class="mobile-toolbar">
    <div class="mobile-toolbar-row" id="mobileTools">
      <button class="mobile-tool-btn active" data-tool="cursor">Select</button>
      <button class="mobile-tool-btn" data-tool="dribble">Dribble</button>
      <button class="mobile-tool-btn" data-tool="pmove">Move</button>
      <button class="mobile-tool-btn" data-tool="screen">Screen</button>
      <button class="mobile-tool-btn" data-tool="pass">Pass</button>
      <button class="mobile-tool-btn" data-tool="draw">Draw</button>
      <button class="mobile-tool-btn" data-tool="eraser">Eraser</button>
      <button class="mobile-tool-btn" data-tool="text">Text</button>
      <button class="mobile-tool-btn" id="mobileMoreBtn">More...</button>
    </div>
    <div class="mobile-expand-panel" id="mobilePanel">
      <button class="mobile-tool-btn" data-court-m="full">Full Court</button>
      <button class="mobile-tool-btn active" data-court-m="half">Half Court</button>
      <button class="mobile-tool-btn" data-formation-m="2-3">2-3 Zone</button>
      <button class="mobile-tool-btn" data-formation-m="3-2">3-2 Zone</button>
      <button class="mobile-tool-btn" data-formation-m="1-3-1">1-3-1</button>
      <button class="mobile-tool-btn" data-formation-m="man-to-man">Man</button>
      <button class="mobile-tool-btn" data-formation-m="box-one">Box&1</button>
      <button class="mobile-tool-btn" id="mobileGameLike">Game-like</button>
      <button class="mobile-tool-btn" id="mobileUndo">Undo</button>
      <button class="mobile-tool-btn" id="mobileRedo">Redo</button>
      <button class="mobile-tool-btn" id="mobileClear">Clear</button>
      <button class="mobile-tool-btn" id="mobileReset" style="color:#fca5a5;">Reset</button>
      <button class="mobile-tool-btn" id="mobileExport">Export</button>
    </div>
  </div>
  <script>
    const COURT={width:50,halfLength:47,fullLength:94,basketFromBaseline:5.25,paintWidth:16,paintLength:19,ftCircleRadius:6,threePointRadius:23.75,threeCornerDist:3,restrictedRadius:4,backboardWidth:6,rimRadius:0.75,centerCircleRadius:6};
    const CONFIG={margin:20,courtColor:'#c8823c',paintColor:'rgba(80,50,20,0.25)',lineColor:'#ffffff',lineWidth:2,player:{radius:16,fontSize:11,offenseColor:'#2563eb',defenseColor:'#dc2626',strokeColor:'#ffffff',strokeWidth:2},ballRadius:8};
    const state={courtType:'half',currentTool:'cursor',penColor:'#ffffff',lineWidth:3,players:[],drawings:[],undoStack:[],redoStack:[],isDragging:false,dragPlayer:null,dragOffset:{x:0,y:0},isDrawing:false,currentPath:[],arrowStart:null,pxPerFt:10,marginPx:20,moveCounter:0,trailPath:[],trailStartPos:null,gameLikeMode:false};

    const courtCanvas=document.getElementById('courtCanvas');
    const drawCanvas=document.getElementById('drawCanvas');
    const interactionCanvas=document.getElementById('interactionCanvas');
    const canvasWrapper=document.getElementById('canvasWrapper');
    const courtCtx=courtCanvas.getContext('2d');
    const drawCtx=drawCanvas.getContext('2d');
    const interCtx=interactionCanvas.getContext('2d');

    function cx(ft){return state.marginPx+ft*state.pxPerFt;}
    function cy(ft){return state.marginPx+ft*state.pxPerFt;}
    function sc(ft){return ft*state.pxPerFt;}
    function S(){return state.pxPerFt/10;}

    function resizeCanvases(){
      const container=document.querySelector('.court-container');
      const maxW=container.clientWidth-24,maxH=container.clientHeight-24;
      let courtFtW,courtFtH;
      if(state.courtType==='full'){courtFtW=COURT.width;courtFtH=COURT.fullLength;}
      else{courtFtW=COURT.width;courtFtH=COURT.halfLength;}
      const scaleX=maxW/(courtFtW*10+CONFIG.margin*2);
      const scaleY=maxH/(courtFtH*10+CONFIG.margin*2);
      const scale=Math.min(scaleX,scaleY,1.3);
      state.pxPerFt=10*scale;state.marginPx=CONFIG.margin*scale;
      const w=Math.floor(courtFtW*state.pxPerFt+state.marginPx*2);
      const h=Math.floor(courtFtH*state.pxPerFt+state.marginPx*2);
      [courtCanvas,drawCanvas,interactionCanvas].forEach(c=>{c.width=w;c.height=h;});
      canvasWrapper.style.width=w+'px';canvasWrapper.style.height=h+'px';
      drawCourt();redrawDrawings();drawPlayers();
    }

    // ===== Court Drawing =====
    function drawCourt(){
      const ctx=courtCtx,w=courtCanvas.width,h=courtCanvas.height;
      ctx.clearRect(0,0,w,h);ctx.fillStyle=CONFIG.courtColor;ctx.fillRect(0,0,w,h);
      ctx.strokeStyle=CONFIG.lineColor;ctx.lineWidth=CONFIG.lineWidth*S();ctx.setLineDash([]);
      if(state.courtType==='half') drawHalfCourt(ctx); else drawFullCourt(ctx);
    }
    function drawHalfCourt(ctx){
      const cw=COURT.width,ch=COURT.halfLength,bx=cw/2,by=COURT.basketFromBaseline;
      ctx.strokeRect(cx(0),cy(0),sc(cw),sc(ch));
      const pL=(cw-COURT.paintWidth)/2;
      ctx.fillStyle=CONFIG.paintColor;ctx.fillRect(cx(pL),cy(0),sc(COURT.paintWidth),sc(COURT.paintLength));
      ctx.strokeRect(cx(pL),cy(0),sc(COURT.paintWidth),sc(COURT.paintLength));
      [7,8,11,14].forEach(yy=>{
        ctx.beginPath();ctx.moveTo(cx(pL-0.8),cy(yy));ctx.lineTo(cx(pL),cy(yy));ctx.stroke();
        ctx.beginPath();ctx.moveTo(cx(pL+COURT.paintWidth),cy(yy));ctx.lineTo(cx(pL+COURT.paintWidth+0.8),cy(yy));ctx.stroke();
      });
      ctx.beginPath();ctx.arc(cx(bx),cy(COURT.paintLength),sc(COURT.ftCircleRadius),Math.PI,2*Math.PI);ctx.stroke();
      ctx.setLineDash([sc(0.5),sc(0.5)]);ctx.beginPath();ctx.arc(cx(bx),cy(COURT.paintLength),sc(COURT.ftCircleRadius),0,Math.PI);ctx.stroke();ctx.setLineDash([]);
      drawThreePointLine(ctx,bx,by,cw,0);
      ctx.beginPath();ctx.arc(cx(bx),cy(by),sc(COURT.restrictedRadius),0,Math.PI);ctx.stroke();
      const bbW=COURT.backboardWidth;ctx.lineWidth=(CONFIG.lineWidth+1)*S();
      ctx.beginPath();ctx.moveTo(cx(bx-bbW/2),cy(by-1.25));ctx.lineTo(cx(bx+bbW/2),cy(by-1.25));ctx.stroke();
      ctx.lineWidth=CONFIG.lineWidth*S();
      ctx.beginPath();ctx.arc(cx(bx),cy(by),sc(COURT.rimRadius),0,Math.PI*2);ctx.stroke();
      ctx.beginPath();ctx.arc(cx(bx),cy(ch),sc(COURT.centerCircleRadius),Math.PI,2*Math.PI);ctx.stroke();
    }
    function drawThreePointLine(ctx,basketX,basketY,courtWidth,baselineY){
      const r=COURT.threePointRadius,cornerX=COURT.threeCornerDist;
      const dx=(courtWidth/2)-cornerX,dyS=r*r-dx*dx;if(dyS<0)return;
      const jY=basketY+Math.sqrt(dyS);
      ctx.beginPath();ctx.moveTo(cx(cornerX),cy(baselineY));ctx.lineTo(cx(cornerX),cy(jY));ctx.stroke();
      ctx.beginPath();ctx.moveTo(cx(courtWidth-cornerX),cy(baselineY));ctx.lineTo(cx(courtWidth-cornerX),cy(jY));ctx.stroke();
      const sa=Math.atan2(jY-basketY,(courtWidth-cornerX)-basketX),ea=Math.atan2(jY-basketY,cornerX-basketX);
      ctx.beginPath();ctx.arc(cx(basketX),cy(basketY),sc(r),sa,ea);ctx.stroke();
    }
    function drawFullCourt(ctx){
      const cw=COURT.width,ch=COURT.fullLength;
      ctx.strokeRect(cx(0),cy(0),sc(cw),sc(ch));
      ctx.beginPath();ctx.moveTo(cx(0),cy(ch/2));ctx.lineTo(cx(cw),cy(ch/2));ctx.stroke();
      ctx.beginPath();ctx.arc(cx(cw/2),cy(ch/2),sc(COURT.centerCircleRadius),0,Math.PI*2);ctx.stroke();
      drawHalfCourtSide(ctx,cw,0,COURT.basketFromBaseline,false);
      drawHalfCourtSide(ctx,cw,ch,ch-COURT.basketFromBaseline,true);
    }
    function drawHalfCourtSide(ctx,cW,baseY,bY,flip){
      const bx=cW/2,dir=flip?-1:1,pL=(cW-COURT.paintWidth)/2;
      ctx.fillStyle=CONFIG.paintColor;
      ctx.fillRect(cx(pL),cy(Math.min(baseY,baseY-dir*COURT.paintLength)),sc(COURT.paintWidth),sc(COURT.paintLength));
      ctx.strokeRect(cx(pL),cy(Math.min(baseY,baseY-dir*COURT.paintLength)),sc(COURT.paintWidth),sc(COURT.paintLength));
      [7,8,11,14].forEach(d2=>{const yy=baseY+dir*d2;ctx.beginPath();ctx.moveTo(cx(pL-0.8),cy(yy));ctx.lineTo(cx(pL),cy(yy));ctx.stroke();ctx.beginPath();ctx.moveTo(cx(pL+COURT.paintWidth),cy(yy));ctx.lineTo(cx(pL+COURT.paintWidth+0.8),cy(yy));ctx.stroke();});
      const ftY=baseY+dir*COURT.paintLength;
      ctx.beginPath();ctx.arc(cx(bx),cy(ftY),sc(COURT.ftCircleRadius),flip?0:Math.PI,flip?Math.PI:2*Math.PI);ctx.stroke();
      ctx.setLineDash([sc(0.5),sc(0.5)]);ctx.beginPath();ctx.arc(cx(bx),cy(ftY),sc(COURT.ftCircleRadius),flip?Math.PI:0,flip?2*Math.PI:Math.PI);ctx.stroke();ctx.setLineDash([]);
      const r=COURT.threePointRadius,cX=COURT.threeCornerDist,dx2=(cW/2)-cX,jD=Math.sqrt(r*r-dx2*dx2),jY=bY+dir*jD;
      ctx.beginPath();ctx.moveTo(cx(cX),cy(baseY));ctx.lineTo(cx(cX),cy(jY));ctx.stroke();
      ctx.beginPath();ctx.moveTo(cx(cW-cX),cy(baseY));ctx.lineTo(cx(cW-cX),cy(jY));ctx.stroke();
      const sa2=Math.atan2(jY-bY,(cW-cX)-bx),ea2=Math.atan2(jY-bY,cX-bx);
      ctx.beginPath();ctx.arc(cx(bx),cy(bY),sc(r),sa2,ea2,flip);ctx.stroke();
      ctx.beginPath();ctx.arc(cx(bx),cy(bY),sc(COURT.restrictedRadius),flip?Math.PI:0,flip?2*Math.PI:Math.PI);ctx.stroke();
      const bbY2=bY-dir*1.25;ctx.lineWidth=(CONFIG.lineWidth+1)*S();
      ctx.beginPath();ctx.moveTo(cx(bx-COURT.backboardWidth/2),cy(bbY2));ctx.lineTo(cx(bx+COURT.backboardWidth/2),cy(bbY2));ctx.stroke();
      ctx.lineWidth=CONFIG.lineWidth*S();
      ctx.beginPath();ctx.arc(cx(bx),cy(bY),sc(COURT.rimRadius),0,Math.PI*2);ctx.stroke();
    }

    // ===== Players =====
    const POSITIONS=['PG','SG','SF','PF','C'];
    function get5OutPositions(){
      if(state.courtType==='half'){
        return[
          {x:0.50,y:0.70},  // PG top of key - well beyond 3pt arc
          {x:0.17,y:0.55},  // SG left wing - beyond arc
          {x:0.83,y:0.55},  // SF right wing - beyond arc
          {x:0.06,y:0.18},  // PF left corner - beyond 3pt line
          {x:0.94,y:0.18},  // C right corner - beyond 3pt line
        ];
      } else {
        return[
          {x:0.50,y:0.365}, // PG top - beyond arc
          {x:0.17,y:0.29},  // SG left wing - beyond arc
          {x:0.83,y:0.29},  // SF right wing - beyond arc
          {x:0.06,y:0.09},  // PF left corner - beyond 3pt line
          {x:0.94,y:0.09},  // C right corner - beyond 3pt line
        ];
      }
    }
    function createDefaultPlayers(){
      state.players=[];const w=courtCanvas.width,h=courtCanvas.height;
      const offPos=get5OutPositions();
      offPos.forEach((p,i)=>{state.players.push({x:p.x*w,y:p.y*h,label:POSITIONS[i],team:'offense'});});
      const defPos=getDefenseFormation('man-to-man');
      defPos.forEach((p,i)=>{state.players.push({x:p.x*w,y:p.y*h,label:POSITIONS[i],team:'defense'});});
      const bR=CONFIG.ballRadius*S(),pR=CONFIG.player.radius*S();
      state.players.push({x:offPos[0].x*w+pR+bR+2,y:offPos[0].y*h,label:'',team:'ball'});
    }
    function getDefenseFormation(name){
      const f={
        half:{'2-3':[{x:0.38,y:0.35},{x:0.62,y:0.35},{x:0.18,y:0.18},{x:0.50,y:0.12},{x:0.82,y:0.18}],
          '3-2':[{x:0.25,y:0.35},{x:0.50,y:0.38},{x:0.75,y:0.35},{x:0.35,y:0.18},{x:0.65,y:0.18}],
          '1-3-1':[{x:0.50,y:0.42},{x:0.22,y:0.28},{x:0.78,y:0.28},{x:0.50,y:0.28},{x:0.50,y:0.10}],
          'man-to-man':[{x:0.50,y:0.62},{x:0.19,y:0.49},{x:0.81,y:0.49},{x:0.10,y:0.20},{x:0.90,y:0.20}],
          'box-one':[{x:0.50,y:0.62},{x:0.35,y:0.28},{x:0.65,y:0.28},{x:0.35,y:0.12},{x:0.65,y:0.12}]},
        full:{'2-3':[{x:0.38,y:0.14},{x:0.62,y:0.14},{x:0.18,y:0.08},{x:0.50,y:0.05},{x:0.82,y:0.08}],
          '3-2':[{x:0.25,y:0.14},{x:0.50,y:0.16},{x:0.75,y:0.14},{x:0.35,y:0.07},{x:0.65,y:0.07}],
          '1-3-1':[{x:0.50,y:0.18},{x:0.22,y:0.12},{x:0.78,y:0.12},{x:0.50,y:0.12},{x:0.50,y:0.04}],
          'man-to-man':[{x:0.50,y:0.34},{x:0.19,y:0.27},{x:0.81,y:0.27},{x:0.08,y:0.10},{x:0.92,y:0.10}],
          'box-one':[{x:0.50,y:0.34},{x:0.35,y:0.12},{x:0.65,y:0.12},{x:0.35,y:0.05},{x:0.65,y:0.05}]}
      };
      return f[state.courtType][name]||f[state.courtType]['man-to-man'];
    }
    function drawPlayers(){
      const ctx=interCtx;ctx.clearRect(0,0,interactionCanvas.width,interactionCanvas.height);
      state.players.forEach(p=>{
        if(p.team==='ball'){drawBasketball(ctx,p.x,p.y);return;}
        const r=CONFIG.player.radius*S();
        ctx.beginPath();ctx.arc(p.x,p.y,r,0,Math.PI*2);
        ctx.fillStyle=p.team==='offense'?CONFIG.player.offenseColor:CONFIG.player.defenseColor;
        ctx.fill();ctx.strokeStyle=CONFIG.player.strokeColor;ctx.lineWidth=CONFIG.player.strokeWidth*S();ctx.stroke();
        if(p.label){ctx.fillStyle='#fff';ctx.font=`bold ${CONFIG.player.fontSize*S()}px sans-serif`;ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(p.label,p.x,p.y+0.5);}
      });
    }
    function drawBasketball(ctx,x,y){
      const r=CONFIG.ballRadius*S();
      ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);ctx.fillStyle='#f97316';ctx.fill();
      ctx.strokeStyle='#7c2d12';ctx.lineWidth=1.2*S();ctx.stroke();
      ctx.strokeStyle='#7c2d1280';ctx.lineWidth=0.8*S();
      ctx.beginPath();ctx.moveTo(x-r,y);ctx.lineTo(x+r,y);ctx.stroke();
      ctx.beginPath();ctx.moveTo(x,y-r);ctx.lineTo(x,y+r);ctx.stroke();
      ctx.beginPath();ctx.arc(x-r*0.3,y,r*0.75,-Math.PI*0.4,Math.PI*0.4);ctx.stroke();
      ctx.beginPath();ctx.arc(x+r*0.3,y,r*0.75,Math.PI-Math.PI*0.4,Math.PI+Math.PI*0.4);ctx.stroke();
    }

    // ===== Path helpers =====
    function simplifyPath(pts,minD){
      if(pts.length<3)return[...pts];
      const r=[pts[0]];
      for(let i=1;i<pts.length-1;i++){const l=r[r.length-1],dx=pts[i].x-l.x,dy=pts[i].y-l.y;if(dx*dx+dy*dy>=minD*minD)r.push(pts[i]);}
      r.push(pts[pts.length-1]);return r;
    }
    function getEndDir(pts){
      if(pts.length<2)return{dx:0,dy:-1};
      const a=pts[pts.length-2],b=pts[pts.length-1],dx=b.x-a.x,dy=b.y-a.y,l=Math.sqrt(dx*dx+dy*dy);
      return l>0?{dx:dx/l,dy:dy/l}:{dx:0,dy:-1};
    }
    function drawSmoothCurve(ctx,pts){
      if(pts.length<2)return;
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      if(pts.length===2){ctx.lineTo(pts[1].x,pts[1].y);}
      else{for(let i=1;i<pts.length-1;i++){const mx=(pts[i].x+pts[i+1].x)/2,my=(pts[i].y+pts[i+1].y)/2;ctx.quadraticCurveTo(pts[i].x,pts[i].y,mx,my);}ctx.lineTo(pts[pts.length-1].x,pts[pts.length-1].y);}
    }
    function drawArrowHead(ctx,end,dir,color){
      const hl=12*S(),a=Math.atan2(dir.dy,dir.dx);
      ctx.beginPath();ctx.fillStyle=color;ctx.moveTo(end.x,end.y);
      ctx.lineTo(end.x-hl*Math.cos(a-Math.PI/6),end.y-hl*Math.sin(a-Math.PI/6));
      ctx.lineTo(end.x-hl*Math.cos(a+Math.PI/6),end.y-hl*Math.sin(a+Math.PI/6));
      ctx.closePath();ctx.fill();
    }

    // ===== Trail endpoint trimming =====
    // Trim the last point of a trail so the arrow/bar doesn't overlap the magnet
    function trimTrailEnd(pts,margin){
      if(!pts||pts.length<2)return pts;
      const trimmed=[...pts];
      const end=trimmed[trimmed.length-1];
      const prev=trimmed[trimmed.length-2];
      const dx=end.x-prev.x,dy=end.y-prev.y;
      const l=Math.sqrt(dx*dx+dy*dy);
      if(l>margin){
        trimmed[trimmed.length-1]={x:end.x-(dx/l)*margin,y:end.y-(dy/l)*margin};
      }
      return trimmed;
    }

    // Get rim position in pixel coords
    function getRimPos(){
      const bx=COURT.width/2,by=COURT.basketFromBaseline;
      if(state.courtType==='half'){
        return{x:cx(bx),y:cy(by)};
      } else {
        return{x:cx(bx),y:cy(by)};
      }
    }

    // ===== Drawing System =====
    function redrawDrawings(){drawCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height);state.drawings.forEach(d=>drawSingleDrawing(drawCtx,d));}

    function drawSingleDrawing(ctx,d){
      const s=S();
      if(d.type==='path'){
        // Freehand draw
        if(d.points.length<2)return;
        ctx.strokeStyle=d.color;ctx.lineWidth=d.width*s;ctx.lineCap='round';ctx.lineJoin='round';ctx.setLineDash([]);
        ctx.beginPath();ctx.moveTo(d.points[0].x,d.points[0].y);
        for(let i=1;i<d.points.length;i++)ctx.lineTo(d.points[i].x,d.points[i].y);
        ctx.stroke();
      } else if(d.type==='pmove'){
        // Move trail: smooth curve + arrowhead (trimmed from magnet)
        const rawPts=d.points;if(!rawPts||rawPts.length<2)return;
        const gap=CONFIG.player.radius*s+25*s;
        const pts=trimTrailEnd(rawPts,gap);
        ctx.strokeStyle=d.color;ctx.lineWidth=d.width*s;ctx.lineCap='round';ctx.lineJoin='round';ctx.setLineDash([]);
        drawSmoothCurve(ctx,pts);ctx.stroke();
        drawArrowHead(ctx,pts[pts.length-1],getEndDir(pts),d.color);
        drawSeqNumber(ctx,d);
      } else if(d.type==='dribble'){
        // Dribble trail: zigzag along path + arrowhead (trimmed from magnet)
        const rawPts=d.points;if(!rawPts||rawPts.length<2)return;
        const gap=CONFIG.player.radius*s+25*s;
        const pts=trimTrailEnd(rawPts,gap);
        drawCurvedZigzag(ctx,pts,d.color,d.width*s);
        drawSeqNumber(ctx,d);
      } else if(d.type==='screen'){
        // Screen trail: smooth curve + perpendicular bar (trimmed from magnet)
        const rawPts=d.points;if(!rawPts||rawPts.length<2)return;
        const gap=CONFIG.player.radius*s+25*s;
        const pts=trimTrailEnd(rawPts,gap);
        ctx.strokeStyle=d.color;ctx.lineWidth=d.width*s;ctx.lineCap='round';ctx.lineJoin='round';ctx.setLineDash([]);
        drawSmoothCurve(ctx,pts);ctx.stroke();
        const dir=getEndDir(pts),end=pts[pts.length-1],barL=14*s;
        const px=-dir.dy,py=dir.dx;
        ctx.lineWidth=Math.max(d.width*2*s,5*s);ctx.beginPath();
        ctx.moveTo(end.x-barL*px,end.y-barL*py);ctx.lineTo(end.x+barL*px,end.y+barL*py);ctx.stroke();
        drawSeqNumber(ctx,d);
      } else if(d.type==='pass'){
        // Pass trail: dotted smooth curve + arrowhead (trimmed from ball)
        const rawPts=d.points;if(!rawPts||rawPts.length<2)return;
        const gap=CONFIG.ballRadius*s+25*s;
        const pts=trimTrailEnd(rawPts,gap);
        ctx.strokeStyle=d.color;ctx.lineWidth=d.width*s;ctx.lineCap='round';ctx.lineJoin='round';
        ctx.setLineDash([7*s,5*s]);
        drawSmoothCurve(ctx,pts);ctx.stroke();
        ctx.setLineDash([]);
        drawArrowHead(ctx,pts[pts.length-1],getEndDir(pts),d.color);
        drawSeqNumber(ctx,d);
      } else if(d.type==='text'){
        ctx.fillStyle=d.color;ctx.font=`bold ${14*s}px sans-serif`;ctx.textAlign='center';ctx.textBaseline='middle';
        ctx.fillText(d.text,d.x,d.y);
      }
    }

    function drawCurvedZigzag(ctx,pts,color,width){
      const segs=[];let totalLen=0;
      for(let i=1;i<pts.length;i++){const dx=pts[i].x-pts[i-1].x,dy=pts[i].y-pts[i-1].y;const l=Math.sqrt(dx*dx+dy*dy);segs.push({len:l,dx,dy});totalLen+=l;}
      if(totalLen<5)return;
      const amp=7*S(),numZ=Math.max(4,Math.round(totalLen/(12*S()))),step=totalLen/numZ;
      const zPts=[{x:pts[0].x,y:pts[0].y}];
      let side=1;
      for(let i=1;i<=numZ;i++){
        const tD=i*step;let walked=0,px2,py2,nx,ny;
        for(let j=0;j<segs.length;j++){
          if(walked+segs[j].len>=tD||j===segs.length-1){
            const t=segs[j].len>0?Math.max(0,Math.min(1,(tD-walked)/segs[j].len)):0;
            px2=pts[j].x+t*segs[j].dx;py2=pts[j].y+t*segs[j].dy;
            const sl=segs[j].len||1;nx=-segs[j].dy/sl;ny=segs[j].dx/sl;break;
          }walked+=segs[j].len;
        }
        if(i<numZ){zPts.push({x:px2+nx*amp*side,y:py2+ny*amp*side});side*=-1;}
        else zPts.push({x:pts[pts.length-1].x,y:pts[pts.length-1].y});
      }
      ctx.strokeStyle=color;ctx.lineWidth=width;ctx.lineCap='round';ctx.lineJoin='round';ctx.setLineDash([]);
      ctx.beginPath();ctx.moveTo(zPts[0].x,zPts[0].y);
      for(let i=1;i<zPts.length;i++)ctx.lineTo(zPts[i].x,zPts[i].y);
      ctx.stroke();
      const dir=getEndDir(pts);
      drawArrowHead(ctx,pts[pts.length-1],dir,color);
    }

    // ===== Sequence Number Drawing =====
    function drawSeqNumber(ctx,d){
      if(!d.seq)return;
      const s=S(),pts=d.points;
      if(!pts||pts.length<2)return;
      // Place number near the midpoint of the trail, offset perpendicular
      const midIdx=Math.floor(pts.length/2);
      const mid=pts[midIdx];
      let nx=0,ny=-1;
      if(midIdx>0){
        const dx=pts[midIdx].x-pts[midIdx-1].x,dy=pts[midIdx].y-pts[midIdx-1].y;
        const l=Math.sqrt(dx*dx+dy*dy);
        if(l>0){nx=-dy/l;ny=dx/l;}
      }
      const offDist=16*s;
      const numX=mid.x+nx*offDist;
      const numY=mid.y+ny*offDist;
      // Draw circle background
      const r=10*s;
      ctx.fillStyle='rgba(0,0,0,0.75)';
      ctx.beginPath();ctx.arc(numX,numY,r,0,Math.PI*2);ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,0.5)';ctx.lineWidth=1*s;
      ctx.beginPath();ctx.arc(numX,numY,r,0,Math.PI*2);ctx.stroke();
      // Draw number
      ctx.fillStyle='#ffffff';
      ctx.font=`bold ${11*s}px sans-serif`;
      ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(d.seq.toString(),numX,numY);
    }

    // ===== Trail Preview during drag =====
    function drawTrailPreview(tool,path,color,width){
      const ctx=drawCtx,s=S();
      if(path.length<2)return;
      ctx.strokeStyle=color;ctx.lineWidth=width*s;ctx.lineCap='round';ctx.lineJoin='round';
      if(tool==='pass'){
        ctx.setLineDash([7*s,5*s]);
      } else {
        ctx.setLineDash([]);
      }
      ctx.beginPath();ctx.moveTo(path[0].x,path[0].y);
      for(let i=1;i<path.length;i++)ctx.lineTo(path[i].x,path[i].y);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // ===== Undo/Redo =====
    function saveState(){
      state.undoStack.push({
        players:JSON.parse(JSON.stringify(state.players)),
        drawings:JSON.parse(JSON.stringify(state.drawings)),
        moveCounter:state.moveCounter
      });
      state.redoStack=[];
      if(state.undoStack.length>50)state.undoStack.shift();
    }
    function undo(){
      if(!state.undoStack.length)return;
      state.redoStack.push({
        players:JSON.parse(JSON.stringify(state.players)),
        drawings:JSON.parse(JSON.stringify(state.drawings)),
        moveCounter:state.moveCounter
      });
      const p=state.undoStack.pop();
      state.players=p.players;state.drawings=p.drawings;state.moveCounter=p.moveCounter;
      redrawDrawings();drawPlayers();
    }
    function redo(){
      if(!state.redoStack.length)return;
      state.undoStack.push({
        players:JSON.parse(JSON.stringify(state.players)),
        drawings:JSON.parse(JSON.stringify(state.drawings)),
        moveCounter:state.moveCounter
      });
      const n=state.redoStack.pop();
      state.players=n.players;state.drawings=n.drawings;state.moveCounter=n.moveCounter;
      redrawDrawings();drawPlayers();
    }

    // ===== Formations =====
    function applyFormation(name){
      saveState();const w=courtCanvas.width,h=courtCanvas.height;
      const offPos=get5OutPositions(),defPos=getDefenseFormation(name),np=[];
      offPos.forEach((p,i)=>{np.push({x:p.x*w,y:p.y*h,label:POSITIONS[i],team:'offense'});});
      defPos.forEach((p,i)=>{np.push({x:p.x*w,y:p.y*h,label:POSITIONS[i],team:'defense'});});
      const bR=CONFIG.ballRadius*S(),pR=CONFIG.player.radius*S();
      np.push({x:np[0].x+pR+bR+2,y:np[0].y,label:'',team:'ball'});
      state.players=np;drawPlayers();
    }

    // ===== Player finding helpers =====
    function getCanvasPos(e){const r=interactionCanvas.getBoundingClientRect(),src=e.touches?e.touches[0]||e.changedTouches[0]:e;return{x:src.clientX-r.left,y:src.clientY-r.top};}

    function findPlayerAt(pos){
      const r=CONFIG.player.radius*S();
      for(let i=state.players.length-1;i>=0;i--){
        const p=state.players[i],pr=p.team==='ball'?CONFIG.ballRadius*S():r;
        const dx=pos.x-p.x,dy=pos.y-p.y;
        if(dx*dx+dy*dy<=(pr+4)*(pr+4))return i;
      }
      return-1;
    }

    function findOffensePlayerAt(pos){
      const r=CONFIG.player.radius*S();
      for(let i=state.players.length-1;i>=0;i--){
        const p=state.players[i];
        if(p.team!=='offense')continue;
        const dx=pos.x-p.x,dy=pos.y-p.y;
        if(dx*dx+dy*dy<=(r+6)*(r+6))return i;
      }
      return-1;
    }

    function findBallAt(pos){
      const br=CONFIG.ballRadius*S();
      for(let i=state.players.length-1;i>=0;i--){
        const p=state.players[i];
        if(p.team!=='ball')continue;
        const dx=pos.x-p.x,dy=pos.y-p.y;
        if(dx*dx+dy*dy<=(br+8)*(br+8))return i;
      }
      return-1;
    }

    // ===== Trail tool types =====
    const TRAIL_TOOLS=['dribble','pmove','screen','pass'];

    // ===== Events =====
    function onPointerDown(e){
      e.preventDefault();const pos=getCanvasPos(e);

      if(state.currentTool==='cursor'){
        // Select: drag any player to reposition (no trail)
        const idx=findPlayerAt(pos);
        if(idx>=0){
          saveState();state.isDragging=true;state.dragPlayer=idx;
          state.dragOffset={x:pos.x-state.players[idx].x,y:pos.y-state.players[idx].y};
          interactionCanvas.style.cursor='grabbing';
        }
      } else if(['dribble','pmove','screen'].includes(state.currentTool)){
        // Trail tools for offense players
        const idx=findOffensePlayerAt(pos);
        if(idx>=0){
          saveState();
          state.isDragging=true;
          state.dragPlayer=idx;
          state.trailStartPos={x:state.players[idx].x,y:state.players[idx].y};
          state.trailPath=[{x:state.players[idx].x,y:state.players[idx].y}];
          interactionCanvas.style.cursor='grabbing';
        }
      } else if(state.currentTool==='pass'){
        // Pass tool: drag ball
        const idx=findBallAt(pos);
        if(idx>=0){
          saveState();
          state.isDragging=true;
          state.dragPlayer=idx;
          state.trailStartPos={x:state.players[idx].x,y:state.players[idx].y};
          state.trailPath=[{x:state.players[idx].x,y:state.players[idx].y}];
          interactionCanvas.style.cursor='grabbing';
        }
      } else if(state.currentTool==='draw'){
        saveState();state.isDrawing=true;state.currentPath=[{x:pos.x,y:pos.y}];
      } else if(state.currentTool==='eraser'){
        eraseAt(pos);
      } else if(state.currentTool==='text'){
        const t=prompt('Enter text:');
        if(t){saveState();state.drawings.push({type:'text',x:pos.x,y:pos.y,text:t,color:state.penColor});redrawDrawings();}
      }
    }

    function onPointerMove(e){
      e.preventDefault();const pos=getCanvasPos(e),s=S();

      if(state.currentTool==='cursor'){
        if(state.isDragging&&state.dragPlayer!==null){
          state.players[state.dragPlayer].x=pos.x-state.dragOffset.x;
          state.players[state.dragPlayer].y=pos.y-state.dragOffset.y;
          if(state.gameLikeMode)updateDefensePositions();
          drawPlayers();
        } else {
          interactionCanvas.style.cursor=findPlayerAt(pos)>=0?'grab':'default';
        }
      } else if(TRAIL_TOOLS.includes(state.currentTool)&&state.isDragging){
        // Move the player/ball to cursor position and record trail
        state.players[state.dragPlayer].x=pos.x;
        state.players[state.dragPlayer].y=pos.y;
        state.trailPath.push({x:pos.x,y:pos.y});
        // Game-like mode: update defense positions
        if(state.gameLikeMode)updateDefensePositions();
        // Dribble: move ball with the player, positioned left/right based on direction
        if(state.currentTool==='dribble'){
          const ballIdx=state.players.findIndex(p=>p.team==='ball');
          if(ballIdx>=0){
            const rim=getRimPos();
            const pR=CONFIG.player.radius*S();
            const bR=CONFIG.ballRadius*S();
            const stickDist=pR+bR+1;
            // Vector from rim to player
            const toPlayerX=pos.x-rim.x,toPlayerY=pos.y-rim.y;
            const toPlayerLen=Math.sqrt(toPlayerX*toPlayerX+toPlayerY*toPlayerY)||1;
            // Perpendicular to rim-player line (right-hand normal)
            const perpX=-toPlayerY/toPlayerLen,perpY=toPlayerX/toPlayerLen;
            // Determine if moving right or left relative to rim-player axis
            // Use recent movement direction
            let moveDir=0;
            if(state.trailPath.length>=2){
              const prev=state.trailPath[state.trailPath.length-2];
              const moveDx=pos.x-prev.x,moveDy=pos.y-prev.y;
              // Project movement onto perpendicular axis
              moveDir=moveDx*perpX+moveDy*perpY;
            }
            // Position ball on left or right side of player
            const side=moveDir>=0?1:-1;
            state.players[ballIdx].x=pos.x+perpX*stickDist*side;
            state.players[ballIdx].y=pos.y+perpY*stickDist*side;
          }
        }
        drawPlayers();
        // Draw trail preview
        redrawDrawings();
        drawTrailPreview(state.currentTool,state.trailPath,state.penColor,state.lineWidth);
      } else if(state.currentTool==='draw'&&state.isDrawing){
        state.currentPath.push(pos);
        redrawDrawings();
        const ctx=drawCtx;
        ctx.beginPath();ctx.strokeStyle=state.penColor;ctx.lineWidth=state.lineWidth*s;ctx.lineCap='round';ctx.lineJoin='round';ctx.setLineDash([]);
        ctx.moveTo(state.currentPath[0].x,state.currentPath[0].y);
        for(let i=1;i<state.currentPath.length;i++)ctx.lineTo(state.currentPath[i].x,state.currentPath[i].y);
        ctx.stroke();
      } else if(state.currentTool==='eraser'&&(e.buttons>0||e.touches)){
        eraseAt(pos);
      } else if(TRAIL_TOOLS.includes(state.currentTool)&&!state.isDragging){
        // Show grab cursor when hovering over valid targets
        if(state.currentTool==='pass'){
          interactionCanvas.style.cursor=findBallAt(pos)>=0?'grab':'crosshair';
        } else {
          interactionCanvas.style.cursor=findOffensePlayerAt(pos)>=0?'grab':'crosshair';
        }
      }
    }

    function onPointerUp(e){
      if(state.currentTool==='cursor'&&state.isDragging){
        state.isDragging=false;state.dragPlayer=null;interactionCanvas.style.cursor='default';
      } else if(TRAIL_TOOLS.includes(state.currentTool)&&state.isDragging){
        state.isDragging=false;
        if(state.trailPath.length>2){
          state.moveCounter++;
          const simplified=simplifyPath(state.trailPath,8*S());
          state.drawings.push({
            type:state.currentTool,
            points:simplified,
            color:state.penColor,
            width:state.lineWidth,
            seq:state.moveCounter
          });
        }
        state.trailPath=[];
        state.trailStartPos=null;
        state.dragPlayer=null;
        interactionCanvas.style.cursor='crosshair';
        redrawDrawings();drawPlayers();
      } else if(state.currentTool==='draw'&&state.isDrawing){
        state.isDrawing=false;
        if(state.currentPath.length>1)state.drawings.push({type:'path',points:[...state.currentPath],color:state.penColor,width:state.lineWidth});
        state.currentPath=[];redrawDrawings();
      }
    }

    function eraseAt(pos){
      const er=18*S();let erased=false;
      for(let i=state.drawings.length-1;i>=0;i--){
        const d=state.drawings[i];let hit=false;
        if(d.type==='path'||d.type==='pmove'||d.type==='dribble'||d.type==='screen'||d.type==='pass'){
          if(d.points)for(const pt of d.points){if((pt.x-pos.x)**2+(pt.y-pos.y)**2<er*er){hit=true;break;}}
        } else if(d.type==='text'){hit=(d.x-pos.x)**2+(d.y-pos.y)**2<er*er*2;}
        if(hit){
          if(!erased)saveState();
          // If erasing a trail with a sequence number, adjust counter
          state.drawings.splice(i,1);erased=true;
        }
      }
      if(erased){
        // Renumber remaining trail sequences
        let counter=0;
        state.drawings.forEach(d=>{
          if(d.seq!==undefined){counter++;d.seq=counter;}
        });
        state.moveCounter=counter;
        redrawDrawings();
      }
    }
    function distToSeg(p,v,w){const l2=(w.x-v.x)**2+(w.y-v.y)**2;if(l2===0)return Math.sqrt((p.x-v.x)**2+(p.y-v.y)**2);let t=((p.x-v.x)*(w.x-v.x)+(p.y-v.y)*(w.y-v.y))/l2;t=Math.max(0,Math.min(1,t));return Math.sqrt((p.x-(v.x+t*(w.x-v.x)))**2+(p.y-(v.y+t*(w.y-v.y)))**2);}

    // ===== Game-like Mode: Defense AI =====
    // Basketball defensive principles:
    // 1. Ball-You-Man: Defender stays on the line between ball and their man,
    //    cheating toward the ball side ("one pass away" = deny, "two+ passes away" = help)
    // 2. Help side / Ball side: Defenders on the weak side sag into the paint
    //    to provide help defense and protect the rim
    // 3. On-ball defender: Stays between ball handler and rim (close pressure)
    // 4. One pass away: Deny position (close to their man, in passing lane)
    // 5. Two+ passes away: Help position (sag toward paint/rim, see ball and man)
    // 6. Screen defense: Defender of screener shows/hedges, then recovers
    // 7. Protect the paint: Defenders collapse when ball penetrates inside the arc

    function updateDefensePositions(){
      if(!state.gameLikeMode)return;
      const rim=getRimPos();
      const offPlayers=state.players.filter(p=>p.team==='offense');
      const defPlayers=state.players.filter(p=>p.team==='defense');
      const ball=state.players.find(p=>p.team==='ball');
      if(!ball||offPlayers.length!==5||defPlayers.length!==5)return;

      const pR=CONFIG.player.radius*S();
      const w=courtCanvas.width,h=courtCanvas.height;

      // Find which offense player has the ball (closest to ball)
      let ballManIdx=0,minBallDist=Infinity;
      offPlayers.forEach((op,i)=>{
        const d=Math.sqrt((op.x-ball.x)**2+(op.y-ball.y)**2);
        if(d<minBallDist){minBallDist=d;ballManIdx=i;}
      });

      // Determine ball side (left/right of court center)
      const courtCenterX=cx(COURT.width/2);
      const ballSide=ball.x<courtCenterX?'left':'right';

      // For each defender, compute ideal position
      offPlayers.forEach((offP,i)=>{
        const def=defPlayers[i];
        const isBallMan=(i===ballManIdx);

        // Vector from rim to offense player
        const toOffX=offP.x-rim.x,toOffY=offP.y-rim.y;
        const toOffDist=Math.sqrt(toOffX*toOffX+toOffY*toOffY)||1;

        // Vector from rim to ball
        const toBallX=ball.x-rim.x,toBallY=ball.y-rim.y;
        const toBallDist=Math.sqrt(toBallX*toBallX+toBallY*toBallY)||1;

        // Distance from offense player to ball
        const offToBallDist=Math.sqrt((offP.x-ball.x)**2+(offP.y-ball.y)**2);

        let targetX,targetY;

        if(isBallMan){
          // ON-BALL DEFENSE: Position between ball handler and rim
          // Close pressure - stay about 1 player radius + small gap from offense
          const guardDist=pR*2.5;
          const dirX=toOffX/toOffDist,dirY=toOffY/toOffDist;
          // Position slightly toward rim from the ball handler
          targetX=offP.x-dirX*guardDist;
          targetY=offP.y-dirY*guardDist;
        } else {
          // OFF-BALL DEFENSE: Position based on distance from ball
          // Calculate "passes away" approximation
          const passesAway=offToBallDist/(sc(10)); // ~10ft per pass

          if(passesAway<1.8){
            // ONE PASS AWAY: Deny position
            // Stay close to man, but in the passing lane (between ball and man)
            const ballToManX=offP.x-ball.x,ballToManY=offP.y-ball.y;
            const ballToManDist=Math.sqrt(ballToManX*ballToManX+ballToManY*ballToManY)||1;
            const denyDist=pR*2.2;
            // Position on ball-side of the offensive player
            const denyX=offP.x-(ballToManX/ballToManDist)*denyDist;
            const denyY=offP.y-(ballToManY/ballToManDist)*denyDist;
            // Slight cheat toward rim
            const rimPull=0.15;
            targetX=denyX+(rim.x-denyX)*rimPull;
            targetY=denyY+(rim.y-denyY)*rimPull;
          } else {
            // TWO+ PASSES AWAY: Help position
            // Sag toward the paint, maintain vision of ball and man
            // Position = weighted blend between man and rim, biased toward rim
            const helpBias=Math.min(0.5,0.25+passesAway*0.05);
            // Base help position: between man and rim
            const helpBaseX=offP.x+(rim.x-offP.x)*helpBias;
            const helpBaseY=offP.y+(rim.y-offP.y)*helpBias;
            // Also shift toward ball side slightly for help rotation
            const ballPull=0.12;
            targetX=helpBaseX+(ball.x-helpBaseX)*ballPull;
            targetY=helpBaseY+(ball.y-helpBaseY)*ballPull;
          }
        }

        // Clamp to court bounds
        targetX=Math.max(state.marginPx+pR,Math.min(w-state.marginPx-pR,targetX));
        targetY=Math.max(state.marginPx+pR,Math.min(h-state.marginPx-pR,targetY));

        // Smooth movement (ease toward target)
        const ease=0.25;
        def.x+=(targetX-def.x)*ease;
        def.y+=(targetY-def.y)*ease;
      });
    }

    function toggleGameLikeMode(){
      state.gameLikeMode=!state.gameLikeMode;
      const btn=document.getElementById('gameLikeBtn');
      const mBtn=document.getElementById('mobileGameLike');
      if(state.gameLikeMode){
        btn.style.borderColor='var(--btn-active)';btn.style.background='rgba(37,99,235,0.2)';
        if(mBtn){mBtn.style.borderColor='var(--btn-active)';mBtn.style.background='rgba(37,99,235,0.2)';}
      } else {
        btn.style.borderColor='transparent';btn.style.background='var(--btn-bg)';
        if(mBtn){mBtn.style.borderColor='transparent';mBtn.style.background='var(--btn-bg)';}
      }
    }

    // ===== Basketball Knowledge Engine =====
    // Court: 50ft wide (x: 0=left sideline, 50=right), 47ft deep (y: 0=baseline, 47=halfcourt)
    // Rim at (25, 5.25), FT line at y=19, 3pt arc radius=23.75ft from rim

    const COURT_GRID={
      Rim:            {x:25,   y:5.25},
      DunkerL:        {x:21,   y:4.5},
      DunkerR:        {x:29,   y:4.5},
      LowPostL:       {x:19,   y:8},
      LowPostR:       {x:31,   y:8},
      LowBlockL:      {x:17,   y:7},
      LowBlockR:      {x:33,   y:7},
      MidPostL:       {x:17,   y:13},
      MidPostR:       {x:33,   y:13},
      PaintCenter:    {x:25,   y:12},
      PaintLow:       {x:25,   y:8},
      PaintHigh:      {x:25,   y:16},
      PaintL:         {x:20,   y:12},
      PaintR:         {x:30,   y:12},
      ElbowL:         {x:17,   y:19},
      ElbowR:         {x:33,   y:19},
      FreeThrow:      {x:25,   y:19},
      HighPostL:      {x:19,   y:17},
      HighPostR:      {x:31,   y:17},
      ShortCornerL:   {x:7,    y:8},
      ShortCornerR:   {x:43,   y:8},
      CornerL:        {x:3,    y:7},
      CornerR:        {x:47,   y:7},
      WingL:          {x:6,    y:24},
      WingR:          {x:44,   y:24},
      WingExtL:       {x:4,    y:18},
      WingExtR:       {x:46,   y:18},
      SlotL:          {x:13,   y:30},
      SlotR:          {x:37,   y:30},
      TopKey:         {x:25,   y:31},
      TopL:           {x:18,   y:32},
      TopR:           {x:32,   y:32},
      TopExtended:    {x:25,   y:38},
      BallScreenTop:  {x:27,   y:28},
      BallScreenL:    {x:23,   y:28},
      PinDownL:       {x:17,   y:15},
      PinDownR:       {x:33,   y:15},
    };

    function courtPos(name){
      const p=COURT_GRID[name];
      if(!p){return{x:cx(25),y:cy(25)};}
      return{x:cx(p.x),y:cy(p.y)};
    }

    const PLAYER_LABELS=['PG','SG','SF','PF','C'];

    // ===== Basketball Timing Principles =====
    // 1. : 
    // 2. 1=1: /
    // 3. : 
    // 4. : 

    const TACTICS_DATA={tactics:[
      {
        id:'pattern_1',
        name:'P&R Tag & Backdoor',
        description:'',
        explanation:'CPGPGCX4CPFDFPG',
        initPositions:{PG:'TopKey',SG:'WingL',SF:'CornerL',PF:'WingR',C:'CornerR'},
        ballHandler:'PG',
        steps:[
          {
            step:1,
            action:'C sets ball screen',
            description:'CPG',
            moves:[
              {player:'C',from:'CornerR',to:'BallScreenTop',path:'linear',role:'screener'}
            ]
          },
          {
            step:2,
            action:'PG drives + C rolls',
            description:'PGCP&R',
            condition:'X5  C',
            moves:[
              {player:'PG',from:'TopKey',to:'SlotR',path:'curved_right',state:'dribbling'},
              {player:'C',from:'BallScreenTop',to:'PaintCenter',path:'roll_dive'}
            ]
          },
          {
            step:3,
            action:'PF reads tag & backdoor cuts',
            description:'X4C  PF',
            condition:'X4C  PF',
            defenseDelay:{PF:0.75},
            moves:[
              {player:'PF',from:'WingR',to:'DunkerR',path:'backdoor'}
            ]
          },
          {
            step:4,
            action:'PG passes to open PF',
            description:'PFDFPG  ',
            moves:[
              {player:'PG',action:'pass',target:'PF',passType:'bounce',passAt:0.4},
              {player:'PF',action:'layup',at:'Rim'}
            ]
          }
        ]
      },
      {
        id:'pattern_2',
        name:'Pin-down to High-Low',
        description:'',
        explanation:'PGSFPGSGSGCX5PF',
        initPositions:{PG:'TopKey',SG:'CornerL',SF:'WingR',PF:'CornerR',C:'WingL'},
        ballHandler:'PG',
        steps:[
          {
            step:1,
            action:'PG passes to SF',
            description:'PGSF',
            moves:[
              {player:'PG',action:'pass',target:'SF',passAt:0.3}
            ]
          },
          {
            step:2,
            action:'PG sets pin-down for SG',
            description:'PGSGDFX2',
            moves:[
              {player:'PG',from:'TopKey',to:'PinDownL',path:'linear',role:'screener'}
            ]
          },
          {
            step:3,
            action:'SG curls + PG fades',
            description:'SGPG',
            condition:'X2  SG',
            moves:[
              {player:'SG',from:'CornerL',to:'FreeThrow',path:'curl_around_screen'},
              {player:'PG',from:'PinDownL',to:'CornerL',path:'linear'}
            ]
          },
          {
            step:4,
            action:'C flashes to high post',
            description:'SGDFC',
            moves:[
              {player:'C',from:'WingL',to:'ElbowL',path:'flash'}
            ]
          },
          {
            step:5,
            action:'SF passes to C',
            description:'CSF',
            moves:[
              {player:'SF',action:'pass',target:'C',passAt:0.3}
            ]
          },
          {
            step:6,
            action:'PF dives to low post',
            description:'X5C  PF',
            condition:'X5  ',
            defenseDelay:{PF:0.7},
            moves:[
              {player:'PF',from:'CornerR',to:'DunkerR',path:'flash'}
            ]
          },
          {
            step:7,
            action:'C feeds PF high-low',
            description:'DFPFC  ',
            moves:[
              {player:'C',action:'pass',target:'PF',passType:'high_low',passAt:0.4},
              {player:'PF',action:'layup',at:'Rim'}
            ]
          }
        ]
      },
      {
        id:'pattern_3',
        name:'Spanish P&R (Stack)',
        description:'DF',
        explanation:'CPGSGCDFX5PGCSGDF',
        initPositions:{PG:'TopKey',SG:'WingL',SF:'CornerR',PF:'CornerL',C:'WingR'},
        ballHandler:'PG',
        steps:[
          {
            step:1,
            action:'C sets ball screen',
            description:'CPG',
            moves:[
              {player:'C',from:'WingR',to:'BallScreenTop',path:'linear',role:'screener'}
            ]
          },
          {
            step:2,
            action:'SG slides to back-screen spot',
            description:'SGX5',
            moves:[
              {player:'SG',from:'WingL',to:'ElbowR',path:'linear',role:'screener'}
            ]
          },
          {
            step:3,
            action:'PG drives off screen',
            description:'PGC',
            moves:[
              {player:'PG',from:'TopKey',to:'SlotL',path:'curved_left',state:'dribbling'}
            ]
          },
          {
            step:4,
            action:'C rolls free + SG screens X5',
            description:'SGX5X5CSG',
            condition:'X5  C',
            defenseDelay:{C:0.8},
            moves:[
              {player:'C',from:'BallScreenTop',to:'DunkerL',path:'roll_dive'},
              {player:'SG',from:'ElbowR',to:'TopR',path:'linear'}
            ]
          },
          {
            step:5,
            action:'PG lob pass to C',
            description:'DFPGC  ',
            moves:[
              {player:'PG',action:'pass',target:'C',passType:'lob',passAt:0.4},
              {player:'C',action:'dunk',at:'Rim'}
            ]
          }
        ]
      }
    ]};

    // ===== Easing Functions =====
    function easeInOutCubic(t){return t<0.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2;}
    function easeOutQuad(t){return 1-(1-t)*(1-t);}
    function easeInQuad(t){return t*t;}
    function easeExplosive(t){
      // Smooth explosive start: slow setup then burst
      if(t<=0) return 0;
      if(t>=1) return 1;
      return t<0.2 ? 0.5*easeInQuad(t/0.2)*0.2*5 : easeOutQuad((t-0.2)/0.8)*0.9+0.1;
    }

    function bezierPoint(p0,p1,p2,p3,t){
      const u=1-t;
      return{
        x:u*u*u*p0.x+3*u*u*t*p1.x+3*u*t*t*p2.x+t*t*t*p3.x,
        y:u*u*u*p0.y+3*u*u*t*p1.y+3*u*t*t*p2.y+t*t*t*p3.y
      };
    }

    // ===== Movement Path Calculator =====
    function calcPathPoints(fromName,toName,pathType,numPts){
      numPts=numPts||24;
      const fp=courtPos(fromName),tp=courtPos(toName);
      const rimP=courtPos('Rim');
      const courtCenter=cx(25);
      const pts=[];

      if(pathType==='curved_right'){
        const dx=tp.x-fp.x,dy=tp.y-fp.y;
        for(let i=0;i<=numPts;i++){
          const t=i/numPts;
          const bulge=Math.sin(t*Math.PI)*0.2;
          pts.push({x:fp.x+dx*t+Math.abs(dy)*bulge,y:fp.y+dy*t-Math.abs(dx)*bulge*0.3});
        }
      }
      else if(pathType==='curved_left'){
        const dx=tp.x-fp.x,dy=tp.y-fp.y;
        for(let i=0;i<=numPts;i++){
          const t=i/numPts;
          const bulge=Math.sin(t*Math.PI)*0.2;
          pts.push({x:fp.x+dx*t-Math.abs(dy)*bulge,y:fp.y+dy*t-Math.abs(dx)*bulge*0.3});
        }
      }
      else if(pathType==='roll_dive'){
        const dx=tp.x-fp.x,dy=tp.y-fp.y;
        const perpX=-dy*0.35,perpY=dx*0.35;
        for(let i=0;i<=numPts;i++){
          const t=i/numPts;
          const curve=Math.sin(t*Math.PI)*0.5;
          const ease=t<0.3?easeInQuad(t/0.3)*0.3:0.3+0.7*easeOutQuad((t-0.3)/0.7);
          pts.push({
            x:fp.x+(tp.x-fp.x)*ease+perpX*curve*(1-t),
            y:fp.y+(tp.y-fp.y)*ease+perpY*curve*(1-t)
          });
        }
      }
      else if(pathType==='backdoor'){
        // Fake step away from basket, then burst cut to rim
        const awayX=(fp.x>courtCenter)?sc(4):-sc(4);
        const awayY=sc(3);
        const fakeX=fp.x+awayX, fakeY=fp.y+awayY;
        for(let i=0;i<=numPts;i++){
          const t=i/numPts;
          if(t<0.25){
            const t2=easeOutQuad(t/0.25);
            pts.push({x:fp.x+(fakeX-fp.x)*t2,y:fp.y+(fakeY-fp.y)*t2});
          } else {
            const t2=easeExplosive((t-0.25)/0.75);
            pts.push({x:fakeX+(tp.x-fakeX)*t2,y:fakeY+(tp.y-fakeY)*t2});
          }
        }
      }
      else if(pathType==='curl_around_screen'){
        const dx=tp.x-fp.x,dy=tp.y-fp.y;
        const cp1={x:fp.x,y:fp.y+(tp.y-fp.y)*0.4};
        const cp2={x:fp.x+(tp.x-fp.x)*0.3,y:tp.y+Math.abs(dx)*0.15};
        for(let i=0;i<=numPts;i++){
          const t=i/numPts;
          pts.push(bezierPoint(fp,cp1,cp2,tp,easeInOutCubic(t)));
        }
      }
      else if(pathType==='flash'){
        for(let i=0;i<=numPts;i++){
          const t=i/numPts;
          const et=easeExplosive(t);
          pts.push({x:fp.x+(tp.x-fp.x)*et,y:fp.y+(tp.y-fp.y)*et});
        }
      }
      else if(pathType==='seal_move'){
        for(let i=0;i<=numPts;i++){
          const t=i/numPts;
          const et=easeInOutCubic(t);
          const curve=Math.sin(t*Math.PI)*sc(2);
          const toRimX=(rimP.x-fp.x),toRimY=(rimP.y-fp.y);
          const len=Math.sqrt(toRimX*toRimX+toRimY*toRimY)||1;
          pts.push({
            x:fp.x+(tp.x-fp.x)*et+(-toRimY/len)*curve,
            y:fp.y+(tp.y-fp.y)*et+(toRimX/len)*curve
          });
        }
      }
      else {
        // linear (default)
        for(let i=0;i<=numPts;i++){
          const t=i/numPts;
          pts.push({x:fp.x+(tp.x-fp.x)*t,y:fp.y+(tp.y-fp.y)*t});
        }
      }
      return pts;
    }

    // ===== Animation State =====
    const anim={
      active:false, playing:false, tactic:null, stepIdx:0,
      progress:0, lastTime:0, stepDuration:1400,
      frame:null, stepStartPositions:{}, passAnim:null,
      stepPaths:{},
      ballHolder:null,
      stepPause:0, // ms remaining in inter-step pause
      defenseDelays:{} // {playerLabel: freezeRatio} for current step
    };

    function getPlayerByLabel(label){
      return state.players.find(p=>p.team==='offense'&&p.label===label);
    }

    // ===== Setup Tactic =====
    function setupTacticPositions(tacticId){
      const tactic=TACTICS_DATA.tactics.find(t=>t.id===tacticId);
      if(!tactic||!tactic.initPositions)return;
      state.players=[];
      // Offense
      PLAYER_LABELS.forEach(label=>{
        const posName=tactic.initPositions[label];
        const p=courtPos(posName);
        state.players.push({x:p.x,y:p.y,label:label,team:'offense'});
      });
      // Defense between man and rim
      const rim=getRimPos();
      PLAYER_LABELS.forEach((label,i)=>{
        const off=state.players[i];
        const dx=rim.x-off.x,dy=rim.y-off.y;
        const d=Math.sqrt(dx*dx+dy*dy)||1;
        const gap=CONFIG.player.radius*S()*2.5;
        state.players.push({x:off.x+dx/d*gap,y:off.y+dy/d*gap,label:label,team:'defense'});
      });
      // Ball
      anim.ballHolder=tactic.ballHandler||'PG';
      const handler=getPlayerByLabel(anim.ballHolder);
      if(handler){
        const pR=CONFIG.player.radius*S(),bR=CONFIG.ballRadius*S();
        state.players.push({x:handler.x+pR+bR+2,y:handler.y,label:'',team:'ball'});
      }
      // Settle defense
      const saved=state.gameLikeMode;
      state.gameLikeMode=true;
      for(let i=0;i<20;i++)updateDefensePositions();
      state.gameLikeMode=saved;
    }

    // ===== Pre-compute paths =====
    function precomputeStepPaths(){
      anim.stepPaths={};anim.passAnim=null;
      if(!anim.tactic)return;
      const step=anim.tactic.steps[anim.stepIdx];
      if(!step||!step.moves)return;
      // Load defense delays for this step
      anim.defenseDelays=step.defenseDelay||{};
      step.moves.forEach(move=>{
        if(move.action==='pass'||move.action==='layup'||move.action==='dunk')return;
        if(!move.from||!move.to||move.from===move.to)return;
        anim.stepPaths[move.player]=calcPathPoints(move.from,move.to,move.path,24);
      });
    }

    function saveStepStartPositions(){
      anim.stepStartPositions={};
      state.players.forEach(p=>{
        if(p.team==='offense')anim.stepStartPositions[p.label]={x:p.x,y:p.y};
      });
      const ball=state.players.find(p=>p.team==='ball');
      if(ball)anim.stepStartPositions['ball']={x:ball.x,y:ball.y};
    }

    function updateStepInfo(){
      if(!anim.tactic)return;
      const step=anim.tactic.steps[anim.stepIdx];
      if(!step)return;
      document.getElementById('stepTitle').textContent='Step '+step.step+': '+step.action;
      document.getElementById('stepDesc').textContent=step.description||'';
      document.getElementById('stepCondition').textContent=step.condition?(' '+step.condition):'';
    }

    // ===== Select & Play =====
    function selectTactic(id){
      stopTacticAnim();
      const tactic=TACTICS_DATA.tactics.find(t=>t.id===id);
      if(!tactic)return;
      anim.tactic=tactic;anim.stepIdx=0;anim.progress=0;anim.active=true;anim.stepPause=0;
      state.drawings=[];state.moveCounter=0;redrawDrawings();
      setupTacticPositions(id);
      saveStepStartPositions();
      precomputeStepPaths();
      drawPlayers();
      document.querySelectorAll('.tactics-btn').forEach(b=>b.classList.toggle('active',b.dataset.tacticId===id));
      document.getElementById('playbackControls').style.display='flex';
      document.getElementById('stepInfo').style.display='block';
      document.getElementById('tacticExplanation').style.display='block';
      document.getElementById('tacticExplanation').textContent=tactic.explanation;
      updateStepInfo();
    }

    function playTacticAnim(){
      if(!anim.tactic)return;
      if(anim.playing){pauseTacticAnim();return;}
      anim.playing=true;anim.lastTime=performance.now();anim.stepPause=0;
      document.getElementById('tacticPlay').textContent=' Pause';
      document.getElementById('tacticPlay').classList.add('playing');
      anim.frame=requestAnimationFrame(tacticAnimLoop);
    }
    function pauseTacticAnim(){
      anim.playing=false;
      if(anim.frame){cancelAnimationFrame(anim.frame);anim.frame=null;}
      document.getElementById('tacticPlay').textContent=' Play';
      document.getElementById('tacticPlay').classList.remove('playing');
    }
    function stopTacticAnim(){
      pauseTacticAnim();
      anim.active=false;anim.tactic=null;anim.stepIdx=0;anim.progress=0;
      anim.passAnim=null;anim.stepPaths={};anim.ballHolder=null;anim.stepPause=0;anim.defenseDelays={};
      document.querySelectorAll('.tactics-btn').forEach(b=>b.classList.remove('active'));
      document.getElementById('playbackControls').style.display='none';
      document.getElementById('stepInfo').style.display='none';
      document.getElementById('tacticExplanation').style.display='none';
    }

    // ===== Animation Loop (fixed step transition) =====
    function tacticAnimLoop(timestamp){
      if(!anim.playing)return;
      const dt=timestamp-anim.lastTime;
      anim.lastTime=timestamp;

      // Inter-step pause
      if(anim.stepPause>0){
        anim.stepPause-=dt;
        anim.frame=requestAnimationFrame(tacticAnimLoop);
        return;
      }

      anim.progress+=dt/anim.stepDuration;

      if(anim.progress>=1){
        anim.progress=1;
        applyStepInterpolation(1);
        applyStepEnd();
        drawPlayers();redrawDrawings();

        if(anim.stepIdx<anim.tactic.steps.length-1){
          anim.stepIdx++;anim.progress=0;
          saveStepStartPositions();
          precomputeStepPaths();
          updateStepInfo();
          anim.stepPause=500; // 500ms pause between steps
          anim.frame=requestAnimationFrame(tacticAnimLoop);
        } else {
          pauseTacticAnim();
        }
        return;
      }

      // Clamp progress to valid range
      const t=Math.max(0,Math.min(1,anim.progress));
      applyStepInterpolation(t);
      updateDefensePositions_tactic(anim.progress);
      drawPlayers();
      redrawDrawings();
      if(anim.passAnim)drawPassAnimation();

      anim.frame=requestAnimationFrame(tacticAnimLoop);
    }

    // ===== Defense reaction during tactics =====
    // defenseDelay: {playerLabel: freezeRatio}  defender is frozen (caught by screen)
    // for the first freezeRatio portion of the step, then slowly recovers
    function updateDefensePositions_tactic(t){
      const rim=getRimPos();
      const offPlayers=state.players.filter(p=>p.team==='offense');
      const defPlayers=state.players.filter(p=>p.team==='defense');
      const ball=state.players.find(p=>p.team==='ball');
      if(!ball||offPlayers.length!==5||defPlayers.length!==5)return;
      const pR=CONFIG.player.radius*S();
      const w=courtCanvas.width,h=courtCanvas.height;

      let ballManIdx=0,minD=Infinity;
      offPlayers.forEach((op,i)=>{
        const d=Math.sqrt((op.x-ball.x)**2+(op.y-ball.y)**2);
        if(d<minD){minD=d;ballManIdx=i;}
      });

      offPlayers.forEach((offP,i)=>{
        const def=defPlayers[i];
        const isBallMan=(i===ballManIdx);
        const toOffX=offP.x-rim.x,toOffY=offP.y-rim.y;
        const toOffDist=Math.sqrt(toOffX*toOffX+toOffY*toOffY)||1;
        const offToBallDist=Math.sqrt((offP.x-ball.x)**2+(offP.y-ball.y)**2);
        let targetX,targetY;

        if(isBallMan){
          const guardDist=pR*2.5;
          targetX=offP.x-(toOffX/toOffDist)*guardDist;
          targetY=offP.y-(toOffY/toOffDist)*guardDist;
        } else {
          const passesAway=offToBallDist/sc(10);
          if(passesAway<1.8){
            const bToMX=offP.x-ball.x,bToMY=offP.y-ball.y;
            const bToMD=Math.sqrt(bToMX*bToMX+bToMY*bToMY)||1;
            const denyDist=pR*2.2;
            targetX=offP.x-(bToMX/bToMD)*denyDist;
            targetY=offP.y-(bToMY/bToMD)*denyDist;
            targetX+=(rim.x-targetX)*0.15;
            targetY+=(rim.y-targetY)*0.15;
          } else {
            const helpBias=Math.min(0.5,0.25+passesAway*0.05);
            targetX=offP.x+(rim.x-offP.x)*helpBias;
            targetY=offP.y+(rim.y-offP.y)*helpBias;
            targetX+=(ball.x-targetX)*0.12;
            targetY+=(ball.y-targetY)*0.12;
          }
        }
        targetX=Math.max(state.marginPx+pR,Math.min(w-state.marginPx-pR,targetX));
        targetY=Math.max(state.marginPx+pR,Math.min(h-state.marginPx-pR,targetY));

        // Defense delay: freeze defender when beaten by screen/action
        const delay=anim.defenseDelays[offP.label]||0;
        let chaseSpeed=0.15;
        if(delay>0&&t!==undefined){
          if(t<delay){
            chaseSpeed=0.008; // nearly frozen  defender caught by screen
          } else {
            const recovery=(t-delay)/(1-delay);
            chaseSpeed=0.008+recovery*0.06; // slow recovery, still behind
          }
        }

        def.x+=(targetX-def.x)*chaseSpeed;
        def.y+=(targetY-def.y)*chaseSpeed;
      });
    }

    // ===== Apply Step Interpolation =====
    function applyStepInterpolation(t){
      if(!anim.tactic)return;
      const step=anim.tactic.steps[anim.stepIdx];
      if(!step||!step.moves)return;
      t=Math.max(0,Math.min(1,t)); // safety clamp

      step.moves.forEach(move=>{
        if(move.action==='pass'){
          const passAt=move.passAt||0.3;
          if(t>=passAt&&!anim.passAnim){
            const fromP=getPlayerByLabel(move.player);
            const toP=getPlayerByLabel(move.target);
            if(fromP&&toP){
              anim.passAnim={from:{x:fromP.x,y:fromP.y},toLabel:move.target,startT:t,passType:move.passType};
            }
          }
          if(anim.passAnim&&t>=0.75){
            anim.ballHolder=anim.passAnim.toLabel;
            updateBallPosition();
          }
          return;
        }
        if(move.action==='layup'||move.action==='dunk')return;
        if(!move.from||!move.to||move.from===move.to)return;

        const player=getPlayerByLabel(move.player);
        if(!player)return;

        const path=anim.stepPaths[move.player];
        if(path&&path.length>1){
          const eased=easeInOutCubic(t);
          const rawIdx=eased*(path.length-1);
          const idx=Math.max(0,Math.min(Math.floor(rawIdx),path.length-2));
          const localT=rawIdx-idx;
          player.x=path[idx].x+(path[idx+1].x-path[idx].x)*localT;
          player.y=path[idx].y+(path[idx+1].y-path[idx].y)*localT;
        }

        if(move.state==='dribbling'){
          anim.ballHolder=move.player;
          updateBallPosition();
        }
      });
    }

    function updateBallPosition(){
      if(!anim.ballHolder)return;
      const holder=getPlayerByLabel(anim.ballHolder);
      const ball=state.players.find(p=>p.team==='ball');
      if(!holder||!ball)return;
      const pR=CONFIG.player.radius*S(),bR=CONFIG.ballRadius*S();
      ball.x=holder.x+pR+bR+2;ball.y=holder.y;
    }

    // ===== Step End =====
    // No trails during playbook  clean animation only
    function applyStepEnd(){
      if(!anim.tactic)return;
      const step=anim.tactic.steps[anim.stepIdx];
      if(!step||!step.moves)return;

      step.moves.forEach(move=>{
        if(move.action==='pass'||move.action==='layup'||move.action==='dunk')return;
        if(!move.from||!move.to||move.from===move.to)return;

        // Snap player to exact final position
        const player=getPlayerByLabel(move.player);
        if(player){
          const tp=courtPos(move.to);
          player.x=tp.x;player.y=tp.y;
        }

        if(move.state==='dribbling'){
          anim.ballHolder=move.player;
          updateBallPosition();
        }
      });

      // Handle pass completion (no trail, just transfer ball)
      if(anim.passAnim){
        const toP=getPlayerByLabel(anim.passAnim.toLabel);
        if(toP){
          anim.ballHolder=anim.passAnim.toLabel;
          updateBallPosition();
        }
        anim.passAnim=null;
      }
    }

    // ===== Pass Animation Drawing =====
    function drawPassAnimation(){
      if(!anim.passAnim)return;
      const toP=getPlayerByLabel(anim.passAnim.toLabel);
      if(!toP)return;
      const t=Math.min(1,(anim.progress-anim.passAnim.startT)/0.4);
      if(t<0||t>1)return;
      const from=anim.passAnim.from,to={x:toP.x,y:toP.y};
      const s=S();
      const ctx=drawCtx;
      const et=easeOutQuad(t);
      const bx=from.x+(to.x-from.x)*et,by=from.y+(to.y-from.y)*et;
      ctx.beginPath();ctx.arc(bx,by,CONFIG.ballRadius*s*0.7,0,Math.PI*2);
      ctx.fillStyle='#f97316';ctx.fill();
      ctx.strokeStyle='#7c2d12';ctx.lineWidth=1*s;ctx.stroke();
    }

    // ===== Step Controls =====
    function tacticStepForward(){
      if(!anim.tactic)return;
      pauseTacticAnim();
      anim.progress=1;
      applyStepInterpolation(1);
      applyStepEnd();
      if(anim.stepIdx<anim.tactic.steps.length-1){
        anim.stepIdx++;anim.progress=0;
        saveStepStartPositions();
        precomputeStepPaths();
        updateStepInfo();
      }
      drawPlayers();redrawDrawings();
    }

    function tacticStepBack(){
      if(!anim.tactic||anim.stepIdx<=0)return;
      pauseTacticAnim();
      const targetStep=anim.stepIdx-1;
      state.drawings=[];state.moveCounter=0;
      setupTacticPositions(anim.tactic.id);
      for(let i=0;i<=targetStep;i++){
        anim.stepIdx=i;anim.progress=0;
        saveStepStartPositions();
        precomputeStepPaths();
        anim.progress=1;
        applyStepInterpolation(1);
        applyStepEnd();
      }
      anim.stepIdx=targetStep;anim.progress=0;
      saveStepStartPositions();
      precomputeStepPaths();
      updateStepInfo();
      drawPlayers();redrawDrawings();
    }

    // ===== Build Tactics UI =====
    function buildTacticsUI(){
      const panel=document.getElementById('tacticsPanel');
      TACTICS_DATA.tactics.forEach(t=>{
        const btn=document.createElement('button');
        btn.className='tactics-btn';btn.dataset.tacticId=t.id;
        btn.innerHTML='<strong>'+t.name+'</strong><br><span style="color:#94a3b8;font-size:9px;">'+t.description+'</span>';
        btn.addEventListener('click',()=>selectTactic(t.id));
        panel.appendChild(btn);
      });
    }

    // ===== Export =====
    function exportPNG(){const c=document.createElement('canvas');c.width=courtCanvas.width;c.height=courtCanvas.height;const ctx=c.getContext('2d');ctx.drawImage(courtCanvas,0,0);ctx.drawImage(drawCanvas,0,0);ctx.drawImage(interactionCanvas,0,0);const l=document.createElement('a');l.download='basketball-strategy.png';l.href=c.toDataURL('image/png');l.click();}

    // ===== Tool/Court selection =====
    function selectTool(tool){
      state.currentTool=tool;
      document.querySelectorAll('.tool-btn').forEach(b=>{b.classList.toggle('active',b.dataset.tool===tool);});
      document.querySelectorAll('#mobileTools .mobile-tool-btn').forEach(b=>{b.classList.toggle('active',b.dataset.tool===tool);});
      if(tool==='cursor')interactionCanvas.style.cursor='default';
      else if(tool==='text')interactionCanvas.style.cursor='text';
      else interactionCanvas.style.cursor='crosshair';
    }
    function selectCourtType(type){
      state.courtType=type;state.drawings=[];state.undoStack=[];state.redoStack=[];state.moveCounter=0;
      document.querySelectorAll('.court-type-btn').forEach(b=>{b.classList.toggle('active',b.dataset.court===type);});
      document.querySelectorAll('[data-court-m]').forEach(b=>{b.classList.toggle('active',b.dataset.courtM===type);});
      createDefaultPlayers();resizeCanvases();
    }

    // ===== UI Bindings =====
    document.querySelectorAll('.tool-btn').forEach(b=>{b.addEventListener('click',()=>selectTool(b.dataset.tool));});
    document.querySelectorAll('.court-type-btn').forEach(b=>{b.addEventListener('click',()=>selectCourtType(b.dataset.court));});
    document.querySelectorAll('.color-swatch').forEach(sw=>{sw.addEventListener('click',()=>{document.querySelectorAll('.color-swatch').forEach(s2=>s2.classList.remove('active'));sw.classList.add('active');state.penColor=sw.dataset.color;});});
    document.getElementById('lineWidth').addEventListener('input',e=>{state.lineWidth=parseInt(e.target.value);});
    document.querySelectorAll('[data-formation]').forEach(b=>{b.addEventListener('click',()=>applyFormation(b.dataset.formation));});
    document.getElementById('undoBtn').addEventListener('click',undo);
    document.getElementById('redoBtn').addEventListener('click',redo);
    document.addEventListener('keydown',e=>{if(e.ctrlKey&&e.key==='z'){e.preventDefault();undo();}if(e.ctrlKey&&e.key==='y'){e.preventDefault();redo();}});
    document.getElementById('clearDrawings').addEventListener('click',()=>{saveState();state.drawings=[];state.moveCounter=0;redrawDrawings();});
    document.getElementById('resetAll').addEventListener('click',()=>{if(confirm('Reset all?')){state.drawings=[];state.undoStack=[];state.redoStack=[];state.moveCounter=0;createDefaultPlayers();redrawDrawings();drawPlayers();}});
    document.getElementById('exportBtn').addEventListener('click',exportPNG);
    document.getElementById('gameLikeBtn').addEventListener('click',toggleGameLikeMode);
    // Tactics playback
    document.getElementById('tacticPlay').addEventListener('click',playTacticAnim);
    document.getElementById('tacticNext').addEventListener('click',tacticStepForward);
    document.getElementById('tacticPrev').addEventListener('click',tacticStepBack);
    document.getElementById('tacticStop').addEventListener('click',()=>{stopTacticAnim();createDefaultPlayers();state.drawings=[];state.moveCounter=0;redrawDrawings();drawPlayers();});
    // Mobile
    document.querySelectorAll('#mobileTools .mobile-tool-btn[data-tool]').forEach(b=>{b.addEventListener('click',()=>selectTool(b.dataset.tool));});
    document.getElementById('mobileMoreBtn').addEventListener('click',()=>{document.getElementById('mobilePanel').classList.toggle('open');});
    document.querySelectorAll('[data-court-m]').forEach(b=>{b.addEventListener('click',()=>{selectCourtType(b.dataset.courtM);document.getElementById('mobilePanel').classList.remove('open');});});
    document.querySelectorAll('[data-formation-m]').forEach(b=>{b.addEventListener('click',()=>{applyFormation(b.dataset.formationM);document.getElementById('mobilePanel').classList.remove('open');});});
    document.getElementById('mobileGameLike').addEventListener('click',toggleGameLikeMode);
    document.getElementById('mobileUndo').addEventListener('click',undo);
    document.getElementById('mobileRedo').addEventListener('click',redo);
    document.getElementById('mobileClear').addEventListener('click',()=>{saveState();state.drawings=[];state.moveCounter=0;redrawDrawings();});
    document.getElementById('mobileReset').addEventListener('click',()=>{if(confirm('Reset all?')){state.drawings=[];state.undoStack=[];state.redoStack=[];state.moveCounter=0;createDefaultPlayers();redrawDrawings();drawPlayers();}});
    document.getElementById('mobileExport').addEventListener('click',exportPNG);
    // Canvas events
    interactionCanvas.addEventListener('mousedown',onPointerDown);interactionCanvas.addEventListener('mousemove',onPointerMove);
    interactionCanvas.addEventListener('mouseup',onPointerUp);interactionCanvas.addEventListener('mouseleave',onPointerUp);
    interactionCanvas.addEventListener('touchstart',onPointerDown,{passive:false});interactionCanvas.addEventListener('touchmove',onPointerMove,{passive:false});
    interactionCanvas.addEventListener('touchend',onPointerUp);
    window.addEventListener('resize',resizeCanvases);
    // Init
    buildTacticsUI();
    createDefaultPlayers();resizeCanvases();
  </script>
</body>
</html>
