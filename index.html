<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Basketball Strategy Board</title>
  <style>
    :root {
      --court-color: #c8823c;
      --court-line: #ffffff;
      --offense-color: #2563eb;
      --defense-color: #dc2626;
      --ball-color: #f97316;
      --sidebar-bg: #1e293b;
      --sidebar-text: #f1f5f9;
      --btn-bg: #334155;
      --btn-hover: #475569;
      --btn-active: #2563eb;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0f172a;
      color: var(--sidebar-text);
      overflow: hidden;
      height: 100vh;
      height: 100dvh;
      display: flex;
      flex-direction: column;
      touch-action: none;
    }

    header {
      background: var(--sidebar-bg);
      padding: 6px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid #334155;
      flex-shrink: 0;
    }

    header h1 { font-size: 16px; font-weight: 600; }
    header h1 span { color: var(--ball-color); }

    .main-layout {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .sidebar {
      width: 200px;
      background: var(--sidebar-bg);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow-y: auto;
      border-right: 1px solid #334155;
      flex-shrink: 0;
    }

    .sidebar-section h3 {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #94a3b8;
      margin-bottom: 6px;
    }

    .tool-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px;
    }

    .tool-btn {
      background: var(--btn-bg);
      border: 2px solid transparent;
      color: var(--sidebar-text);
      padding: 6px 4px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 11px;
      text-align: center;
      transition: all 0.15s;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }

    .tool-btn:hover { background: var(--btn-hover); }
    .tool-btn.active {
      border-color: var(--btn-active);
      background: rgba(37, 99, 235, 0.2);
    }
    .tool-btn svg { width: 18px; height: 18px; }

    .action-btn {
      background: var(--btn-bg);
      border: none;
      color: var(--sidebar-text);
      padding: 7px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.15s;
      width: 100%;
      text-align: center;
    }

    .action-btn:hover { background: var(--btn-hover); }
    .action-btn.danger { color: #fca5a5; }
    .action-btn.danger:hover { background: rgba(220, 38, 38, 0.3); }

    .formation-list {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .color-swatch {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      transition: border-color 0.15s;
    }
    .color-swatch.active { border-color: white; }

    .court-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 12px;
      position: relative;
      overflow: hidden;
    }

    .canvas-wrapper {
      position: relative;
      box-shadow: 0 4px 24px rgba(0,0,0,0.5);
      border-radius: 4px;
    }

    canvas { display: block; border-radius: 4px; }
    #courtCanvas { position: absolute; top: 0; left: 0; }
    #drawCanvas { position: absolute; top: 0; left: 0; }
    #interactionCanvas { position: relative; cursor: default; }

    .court-type-toggle { display: flex; gap: 4px; }
    .court-type-btn {
      flex: 1;
      background: var(--btn-bg);
      border: 2px solid transparent;
      color: var(--sidebar-text);
      padding: 5px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 11px;
      text-align: center;
      transition: all 0.15s;
    }
    .court-type-btn:hover { background: var(--btn-hover); }
    .court-type-btn.active {
      border-color: var(--btn-active);
      background: rgba(37, 99, 235, 0.2);
    }

    .undo-redo-btns { display: flex; gap: 4px; }
    .undo-redo-btns .action-btn { flex: 1; }

    /* Mobile bottom toolbar */
    .mobile-toolbar {
      display: none;
      background: var(--sidebar-bg);
      border-top: 1px solid #334155;
      flex-shrink: 0;
    }

    .mobile-toolbar-row {
      display: flex;
      overflow-x: auto;
      gap: 2px;
      padding: 6px 8px;
      -webkit-overflow-scrolling: touch;
    }

    .mobile-toolbar-row::-webkit-scrollbar { display: none; }

    .mobile-tool-btn {
      background: var(--btn-bg);
      border: 2px solid transparent;
      color: var(--sidebar-text);
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 11px;
      white-space: nowrap;
      flex-shrink: 0;
    }
    .mobile-tool-btn:hover { background: var(--btn-hover); }
    .mobile-tool-btn.active {
      border-color: var(--btn-active);
      background: rgba(37, 99, 235, 0.2);
    }

    .mobile-expand-panel {
      display: none;
      padding: 8px;
      gap: 6px;
      flex-wrap: wrap;
      border-top: 1px solid #334155;
      max-height: 200px;
      overflow-y: auto;
    }
    .mobile-expand-panel.open { display: flex; }

    @media (max-width: 768px) {
      header { padding: 4px 12px; }
      header h1 { font-size: 14px; }
      .sidebar { display: none; }
      .mobile-toolbar { display: block; }
      .court-container { padding: 8px; }
    }
  </style>
</head>
<body>
  <header>
    <h1><span>&#127936;</span> Basketball Strategy Board</h1>
    <div style="font-size: 11px; color: #64748b;" class="header-subtitle">Drag &bull; Draw &bull; Plan</div>
  </header>

  <div class="main-layout">
    <div class="sidebar">
      <div class="sidebar-section">
        <h3>Court</h3>
        <div class="court-type-toggle">
          <button class="court-type-btn" data-court="full">Full</button>
          <button class="court-type-btn active" data-court="half">Half</button>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Tools</h3>
        <div class="tool-grid">
          <button class="tool-btn active" data-tool="move" title="Move players">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 9l-3 3 3 3"/><path d="M9 5l3-3 3 3"/><path d="M15 19l-3 3-3-3"/><path d="M19 9l3 3-3 3"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="12" y1="2" x2="12" y2="22"/></svg>
            Move
          </button>
          <button class="tool-btn" data-tool="draw" title="Freehand draw">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/></svg>
            Draw
          </button>
          <button class="tool-btn" data-tool="arrow" title="Pass / Cut">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg>
            Arrow
          </button>
          <button class="tool-btn" data-tool="dashed" title="Screen / Cut">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-dasharray="4 3"><line x1="5" y1="19" x2="19" y2="5"/></svg>
            Dashed
          </button>
          <button class="tool-btn" data-tool="screen" title="Screen">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><line x1="6" y1="12" x2="18" y2="12"/></svg>
            Screen
          </button>
          <button class="tool-btn" data-tool="zigzag" title="Dribble">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="4 20 8 14 12 18 16 10 20 4"/></svg>
            Dribble
          </button>
          <button class="tool-btn" data-tool="eraser" title="Eraser">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 20H7L3 16l9-9 8 8-4 4z"/><line x1="7" y1="20" x2="16" y2="20"/></svg>
            Eraser
          </button>
          <button class="tool-btn" data-tool="text" title="Text label">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="4 7 4 4 20 4 20 7"/><line x1="12" y1="4" x2="12" y2="20"/><line x1="8" y1="20" x2="16" y2="20"/></svg>
            Text
          </button>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Pen Color</h3>
        <div style="display: flex; gap: 5px; flex-wrap: wrap;">
          <div class="color-swatch active" data-color="#ffffff" style="background:#ffffff;"></div>
          <div class="color-swatch" data-color="#facc15" style="background:#facc15;"></div>
          <div class="color-swatch" data-color="#4ade80" style="background:#4ade80;"></div>
          <div class="color-swatch" data-color="#60a5fa" style="background:#60a5fa;"></div>
          <div class="color-swatch" data-color="#f87171" style="background:#f87171;"></div>
          <div class="color-swatch" data-color="#c084fc" style="background:#c084fc;"></div>
        </div>
        <h3 style="margin-top:8px;">Line Width</h3>
        <input type="range" style="width:100%;" id="lineWidth" min="1" max="8" value="3">
      </div>

      <div class="sidebar-section">
        <h3>Defense Formations</h3>
        <div class="formation-list">
          <button class="action-btn" data-formation="2-3">2-3 Zone</button>
          <button class="action-btn" data-formation="3-2">3-2 Zone</button>
          <button class="action-btn" data-formation="1-3-1">1-3-1 Zone</button>
          <button class="action-btn" data-formation="man-to-man">Man-to-Man</button>
          <button class="action-btn" data-formation="box-one">Box & One</button>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>History</h3>
        <div class="undo-redo-btns">
          <button class="action-btn" id="undoBtn">Undo</button>
          <button class="action-btn" id="redoBtn">Redo</button>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Actions</h3>
        <button class="action-btn" id="clearDrawings">Clear Drawings</button>
        <button class="action-btn danger" id="resetAll" style="margin-top:3px;">Reset All</button>
        <button class="action-btn" id="exportBtn" style="margin-top:3px;">Export PNG</button>
      </div>
    </div>

    <div class="court-container">
      <div class="canvas-wrapper" id="canvasWrapper">
        <canvas id="courtCanvas"></canvas>
        <canvas id="drawCanvas"></canvas>
        <canvas id="interactionCanvas"></canvas>
      </div>
    </div>
  </div>

  <!-- Mobile bottom toolbar -->
  <div class="mobile-toolbar">
    <div class="mobile-toolbar-row" id="mobileTools">
      <button class="mobile-tool-btn active" data-tool="move">Move</button>
      <button class="mobile-tool-btn" data-tool="draw">Draw</button>
      <button class="mobile-tool-btn" data-tool="arrow">Arrow</button>
      <button class="mobile-tool-btn" data-tool="dashed">Dashed</button>
      <button class="mobile-tool-btn" data-tool="screen">Screen</button>
      <button class="mobile-tool-btn" data-tool="zigzag">Dribble</button>
      <button class="mobile-tool-btn" data-tool="eraser">Eraser</button>
      <button class="mobile-tool-btn" data-tool="text">Text</button>
      <button class="mobile-tool-btn" id="mobileMoreBtn">More...</button>
    </div>
    <div class="mobile-expand-panel" id="mobilePanel">
      <button class="mobile-tool-btn" data-court-m="full">Full Court</button>
      <button class="mobile-tool-btn active" data-court-m="half">Half Court</button>
      <button class="mobile-tool-btn" data-formation-m="2-3">2-3 Zone</button>
      <button class="mobile-tool-btn" data-formation-m="3-2">3-2 Zone</button>
      <button class="mobile-tool-btn" data-formation-m="1-3-1">1-3-1</button>
      <button class="mobile-tool-btn" data-formation-m="man-to-man">Man</button>
      <button class="mobile-tool-btn" data-formation-m="box-one">Box&1</button>
      <button class="mobile-tool-btn" id="mobileUndo">Undo</button>
      <button class="mobile-tool-btn" id="mobileRedo">Redo</button>
      <button class="mobile-tool-btn" id="mobileClear">Clear</button>
      <button class="mobile-tool-btn" id="mobileReset" style="color:#fca5a5;">Reset</button>
      <button class="mobile-tool-btn" id="mobileExport">Export</button>
    </div>
  </div>

  <script>
    // ===== Court dimensions in feet (NBA) =====
    const COURT = {
      width: 50,        // sideline to sideline
      halfLength: 47,   // baseline to half-court
      fullLength: 94,
      basketFromBaseline: 5.25,
      basketHeight: 10,
      paintWidth: 16,
      paintLength: 19,
      ftCircleRadius: 6,
      threePointRadius: 23.75,
      threeCornerDist: 3,   // from sideline
      restrictedRadius: 4,
      backboardWidth: 6,
      rimRadius: 0.75,
      centerCircleRadius: 6,
    };

    // ===== Config =====
    const CONFIG = {
      margin: 20,
      courtColor: '#c8823c',
      paintColor: 'rgba(80, 50, 20, 0.25)',
      lineColor: '#ffffff',
      lineWidth: 2,
      player: {
        radius: 16,
        fontSize: 11,
        offenseColor: '#2563eb',
        defenseColor: '#dc2626',
        ballColor: '#f97316',
        strokeColor: '#ffffff',
        strokeWidth: 2,
      },
      ballRadius: 8,
    };

    // ===== State =====
    const state = {
      courtType: 'half',
      currentTool: 'move',
      penColor: '#ffffff',
      lineWidth: 3,
      players: [],
      drawings: [],
      undoStack: [],
      redoStack: [],
      isDragging: false,
      dragPlayer: null,
      dragOffset: { x: 0, y: 0 },
      isDrawing: false,
      currentPath: [],
      arrowStart: null,
      pxPerFt: 10,
      marginPx: 20,
    };

    // ===== Canvas =====
    const courtCanvas = document.getElementById('courtCanvas');
    const drawCanvas = document.getElementById('drawCanvas');
    const interactionCanvas = document.getElementById('interactionCanvas');
    const canvasWrapper = document.getElementById('canvasWrapper');
    const courtCtx = courtCanvas.getContext('2d');
    const drawCtx = drawCanvas.getContext('2d');
    const interCtx = interactionCanvas.getContext('2d');

    // Convert court feet to canvas pixels
    function cx(ft) { return state.marginPx + ft * state.pxPerFt; }
    function cy(ft) { return state.marginPx + ft * state.pxPerFt; }
    function sc(ft) { return ft * state.pxPerFt; }

    function resizeCanvases() {
      const container = document.querySelector('.court-container');
      const maxW = container.clientWidth - 24;
      const maxH = container.clientHeight - 24;

      let courtFtW, courtFtH;
      if (state.courtType === 'full') {
        courtFtW = COURT.width;
        courtFtH = COURT.fullLength;
      } else {
        courtFtW = COURT.width;
        courtFtH = COURT.halfLength;
      }

      const totalFtW = courtFtW + CONFIG.margin * 2 / 10;
      const totalFtH = courtFtH + CONFIG.margin * 2 / 10;

      const scaleX = maxW / (courtFtW * 10 + CONFIG.margin * 2);
      const scaleY = maxH / (courtFtH * 10 + CONFIG.margin * 2);
      const scale = Math.min(scaleX, scaleY, 1.3);

      state.pxPerFt = 10 * scale;
      state.marginPx = CONFIG.margin * scale;

      const w = Math.floor(courtFtW * state.pxPerFt + state.marginPx * 2);
      const h = Math.floor(courtFtH * state.pxPerFt + state.marginPx * 2);

      [courtCanvas, drawCanvas, interactionCanvas].forEach(c => {
        c.width = w;
        c.height = h;
      });
      canvasWrapper.style.width = w + 'px';
      canvasWrapper.style.height = h + 'px';

      drawCourt();
      redrawDrawings();
      drawPlayers();
    }

    // ===== Court Drawing =====
    function drawCourt() {
      const ctx = courtCtx;
      const w = courtCanvas.width;
      const h = courtCanvas.height;
      ctx.clearRect(0, 0, w, h);

      // Background
      ctx.fillStyle = CONFIG.courtColor;
      ctx.fillRect(0, 0, w, h);

      ctx.strokeStyle = CONFIG.lineColor;
      ctx.lineWidth = CONFIG.lineWidth * state.pxPerFt / 10;
      ctx.setLineDash([]);

      if (state.courtType === 'half') {
        drawHalfCourt(ctx);
      } else {
        drawFullCourt(ctx);
      }
    }

    function drawHalfCourt(ctx) {
      const cw = COURT.width;
      const ch = COURT.halfLength;

      // Court boundary
      ctx.strokeRect(cx(0), cy(0), sc(cw), sc(ch));

      // Basket position (at TOP of court - baseline is y=0)
      const bx = cw / 2;
      const by = COURT.basketFromBaseline;

      // Paint area
      const paintLeft = (cw - COURT.paintWidth) / 2;
      ctx.fillStyle = CONFIG.paintColor;
      ctx.fillRect(cx(paintLeft), cy(0), sc(COURT.paintWidth), sc(COURT.paintLength));
      ctx.strokeRect(cx(paintLeft), cy(0), sc(COURT.paintWidth), sc(COURT.paintLength));

      // Hash marks on paint sides
      const hashPositions = [7, 8, 11, 14];
      const hashLen = 0.8;
      hashPositions.forEach(yy => {
        // Left side
        ctx.beginPath();
        ctx.moveTo(cx(paintLeft - hashLen), cy(yy));
        ctx.lineTo(cx(paintLeft), cy(yy));
        ctx.stroke();
        // Right side
        ctx.beginPath();
        ctx.moveTo(cx(paintLeft + COURT.paintWidth), cy(yy));
        ctx.lineTo(cx(paintLeft + COURT.paintWidth + hashLen), cy(yy));
        ctx.stroke();
      });

      // Free throw circle - solid top half (away from basket)
      ctx.beginPath();
      ctx.arc(cx(bx), cy(COURT.paintLength), sc(COURT.ftCircleRadius), Math.PI, 2 * Math.PI);
      ctx.stroke();

      // Free throw circle - dashed bottom half (toward basket)
      ctx.setLineDash([sc(0.5), sc(0.5)]);
      ctx.beginPath();
      ctx.arc(cx(bx), cy(COURT.paintLength), sc(COURT.ftCircleRadius), 0, Math.PI);
      ctx.stroke();
      ctx.setLineDash([]);

      // 3-point line
      drawThreePointLine(ctx, bx, by, cw, 0);

      // Restricted area
      ctx.beginPath();
      ctx.arc(cx(bx), cy(by), sc(COURT.restrictedRadius), 0, Math.PI);
      ctx.stroke();

      // Backboard
      const bbW = COURT.backboardWidth;
      ctx.lineWidth = (CONFIG.lineWidth + 1) * state.pxPerFt / 10;
      ctx.beginPath();
      ctx.moveTo(cx(bx - bbW / 2), cy(by - 1.25));
      ctx.lineTo(cx(bx + bbW / 2), cy(by - 1.25));
      ctx.stroke();
      ctx.lineWidth = CONFIG.lineWidth * state.pxPerFt / 10;

      // Rim
      ctx.beginPath();
      ctx.arc(cx(bx), cy(by), sc(COURT.rimRadius), 0, Math.PI * 2);
      ctx.stroke();

      // Center circle (half) at bottom
      ctx.beginPath();
      ctx.arc(cx(bx), cy(ch), sc(COURT.centerCircleRadius), Math.PI, 2 * Math.PI);
      ctx.stroke();
    }

    function drawThreePointLine(ctx, basketX, basketY, courtWidth, baselineY) {
      const r = COURT.threePointRadius;
      const cornerX = COURT.threeCornerDist;

      // Calculate where the arc meets the straight corner lines
      const dx = (courtWidth / 2) - cornerX;
      const dySquared = r * r - dx * dx;
      if (dySquared < 0) return;
      const junctionY = basketY + Math.sqrt(dySquared);

      // Left straight section
      ctx.beginPath();
      ctx.moveTo(cx(cornerX), cy(baselineY));
      ctx.lineTo(cx(cornerX), cy(junctionY));
      ctx.stroke();

      // Right straight section
      ctx.beginPath();
      ctx.moveTo(cx(courtWidth - cornerX), cy(baselineY));
      ctx.lineTo(cx(courtWidth - cornerX), cy(junctionY));
      ctx.stroke();

      // Arc from right junction to left junction (going downward/away from basket)
      const startAngle = Math.atan2(junctionY - basketY, (courtWidth - cornerX) - basketX);
      const endAngle = Math.atan2(junctionY - basketY, cornerX - basketX);

      ctx.beginPath();
      ctx.arc(cx(basketX), cy(basketY), sc(r), startAngle, endAngle);
      ctx.stroke();
    }

    function drawFullCourt(ctx) {
      const cw = COURT.width;
      const ch = COURT.fullLength;

      // Court boundary
      ctx.strokeRect(cx(0), cy(0), sc(cw), sc(ch));

      // Center line
      ctx.beginPath();
      ctx.moveTo(cx(0), cy(ch / 2));
      ctx.lineTo(cx(cw), cy(ch / 2));
      ctx.stroke();

      // Center circle
      ctx.beginPath();
      ctx.arc(cx(cw / 2), cy(ch / 2), sc(COURT.centerCircleRadius), 0, Math.PI * 2);
      ctx.stroke();

      // Top half (basket at top, baseline y=0)
      drawHalfCourtSide(ctx, cw, 0, COURT.basketFromBaseline, false);

      // Bottom half (basket at bottom, baseline y=94)
      drawHalfCourtSide(ctx, cw, ch, ch - COURT.basketFromBaseline, true);
    }

    function drawHalfCourtSide(ctx, courtWidth, baselineY, basketY, flipped) {
      const bx = courtWidth / 2;
      const dir = flipped ? -1 : 1;

      // Paint
      const paintLeft = (courtWidth - COURT.paintWidth) / 2;
      const paintTop = flipped ? baselineY - COURT.paintLength : baselineY;
      ctx.fillStyle = CONFIG.paintColor;
      ctx.fillRect(cx(paintLeft), cy(Math.min(baselineY, baselineY - dir * COURT.paintLength)),
        sc(COURT.paintWidth), sc(COURT.paintLength));
      ctx.strokeRect(cx(paintLeft), cy(Math.min(baselineY, baselineY - dir * COURT.paintLength)),
        sc(COURT.paintWidth), sc(COURT.paintLength));

      // Hash marks
      const hashPositions = [7, 8, 11, 14];
      const hashLen = 0.8;
      hashPositions.forEach(d => {
        const yy = baselineY + dir * d;
        ctx.beginPath();
        ctx.moveTo(cx(paintLeft - hashLen), cy(yy));
        ctx.lineTo(cx(paintLeft), cy(yy));
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx(paintLeft + COURT.paintWidth), cy(yy));
        ctx.lineTo(cx(paintLeft + COURT.paintWidth + hashLen), cy(yy));
        ctx.stroke();
      });

      // Free throw circle
      const ftY = baselineY + dir * COURT.paintLength;
      ctx.beginPath();
      if (flipped) {
        ctx.arc(cx(bx), cy(ftY), sc(COURT.ftCircleRadius), 0, Math.PI);
      } else {
        ctx.arc(cx(bx), cy(ftY), sc(COURT.ftCircleRadius), Math.PI, 2 * Math.PI);
      }
      ctx.stroke();

      ctx.setLineDash([sc(0.5), sc(0.5)]);
      ctx.beginPath();
      if (flipped) {
        ctx.arc(cx(bx), cy(ftY), sc(COURT.ftCircleRadius), Math.PI, 2 * Math.PI);
      } else {
        ctx.arc(cx(bx), cy(ftY), sc(COURT.ftCircleRadius), 0, Math.PI);
      }
      ctx.stroke();
      ctx.setLineDash([]);

      // 3-point line
      const r = COURT.threePointRadius;
      const cornerX = COURT.threeCornerDist;
      const dx = (courtWidth / 2) - cornerX;
      const junctionDist = Math.sqrt(r * r - dx * dx);
      const junctionY = basketY + dir * junctionDist;

      // Corner straight lines
      ctx.beginPath();
      ctx.moveTo(cx(cornerX), cy(baselineY));
      ctx.lineTo(cx(cornerX), cy(junctionY));
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(cx(courtWidth - cornerX), cy(baselineY));
      ctx.lineTo(cx(courtWidth - cornerX), cy(junctionY));
      ctx.stroke();

      // Arc
      const startAngle = Math.atan2((junctionY - basketY) * dir, dx) * dir;
      const endAngle = Math.atan2((junctionY - basketY) * dir, -dx) * dir;

      ctx.beginPath();
      if (flipped) {
        const sa = Math.atan2(junctionY - basketY, (courtWidth - cornerX) - bx);
        const ea = Math.atan2(junctionY - basketY, cornerX - bx);
        ctx.arc(cx(bx), cy(basketY), sc(r), sa, ea, true);
      } else {
        const sa = Math.atan2(junctionY - basketY, (courtWidth - cornerX) - bx);
        const ea = Math.atan2(junctionY - basketY, cornerX - bx);
        ctx.arc(cx(bx), cy(basketY), sc(r), sa, ea);
      }
      ctx.stroke();

      // Restricted area
      ctx.beginPath();
      if (flipped) {
        ctx.arc(cx(bx), cy(basketY), sc(COURT.restrictedRadius), Math.PI, 2 * Math.PI);
      } else {
        ctx.arc(cx(bx), cy(basketY), sc(COURT.restrictedRadius), 0, Math.PI);
      }
      ctx.stroke();

      // Backboard
      const bbW = COURT.backboardWidth;
      const bbY = basketY - dir * 1.25;
      ctx.lineWidth = (CONFIG.lineWidth + 1) * state.pxPerFt / 10;
      ctx.beginPath();
      ctx.moveTo(cx(bx - bbW / 2), cy(bbY));
      ctx.lineTo(cx(bx + bbW / 2), cy(bbY));
      ctx.stroke();
      ctx.lineWidth = CONFIG.lineWidth * state.pxPerFt / 10;

      // Rim
      ctx.beginPath();
      ctx.arc(cx(bx), cy(basketY), sc(COURT.rimRadius), 0, Math.PI * 2);
      ctx.stroke();
    }

    // ===== Players =====
    const POSITIONS = ['PG', 'SG', 'SF', 'PF', 'C'];

    // 5-Out offense positions (fractions of court)
    function get5OutPositions() {
      if (state.courtType === 'half') {
        return [
          { x: 0.50, y: 0.58 }, // PG - top of key
          { x: 0.15, y: 0.40 }, // SG - left wing
          { x: 0.85, y: 0.40 }, // SF - right wing
          { x: 0.10, y: 0.12 }, // PF - left corner
          { x: 0.90, y: 0.12 }, // C - right corner
        ];
      } else {
        return [
          { x: 0.50, y: 0.22 }, // PG
          { x: 0.15, y: 0.32 }, // SG
          { x: 0.85, y: 0.32 }, // SF
          { x: 0.10, y: 0.44 }, // PF
          { x: 0.90, y: 0.44 }, // C
        ];
      }
    }

    function createDefaultPlayers() {
      state.players = [];
      const w = courtCanvas.width;
      const h = courtCanvas.height;

      const offPos = get5OutPositions();
      offPos.forEach((p, i) => {
        state.players.push({ x: p.x * w, y: p.y * h, label: POSITIONS[i], team: 'offense' });
      });

      // Defense in Man-to-Man by default (slightly between offense and basket)
      const defPositions = getDefenseFormation('man-to-man');
      defPositions.forEach((p, i) => {
        state.players.push({ x: p.x * w, y: p.y * h, label: POSITIONS[i], team: 'defense' });
      });

      // Ball
      const ballX = offPos[0].x * w + CONFIG.ballRadius * state.pxPerFt / 10 + CONFIG.player.radius * state.pxPerFt / 10;
      const ballY = offPos[0].y * h;
      state.players.push({ x: ballX, y: ballY, label: '', team: 'ball' });
    }

    function getDefenseFormation(name) {
      const formations = {
        half: {
          '2-3': [
            { x: 0.38, y: 0.35 }, { x: 0.62, y: 0.35 },
            { x: 0.18, y: 0.18 }, { x: 0.50, y: 0.12 }, { x: 0.82, y: 0.18 },
          ],
          '3-2': [
            { x: 0.25, y: 0.35 }, { x: 0.50, y: 0.38 }, { x: 0.75, y: 0.35 },
            { x: 0.35, y: 0.18 }, { x: 0.65, y: 0.18 },
          ],
          '1-3-1': [
            { x: 0.50, y: 0.42 }, { x: 0.22, y: 0.28 }, { x: 0.78, y: 0.28 },
            { x: 0.50, y: 0.28 }, { x: 0.50, y: 0.10 },
          ],
          'man-to-man': [
            { x: 0.50, y: 0.50 }, { x: 0.18, y: 0.34 }, { x: 0.82, y: 0.34 },
            { x: 0.15, y: 0.14 }, { x: 0.85, y: 0.14 },
          ],
          'box-one': [
            { x: 0.50, y: 0.52 }, // chaser follows PG
            { x: 0.35, y: 0.28 }, { x: 0.65, y: 0.28 },
            { x: 0.35, y: 0.12 }, { x: 0.65, y: 0.12 },
          ],
        },
        full: {
          '2-3': [
            { x: 0.38, y: 0.14 }, { x: 0.62, y: 0.14 },
            { x: 0.18, y: 0.08 }, { x: 0.50, y: 0.05 }, { x: 0.82, y: 0.08 },
          ],
          '3-2': [
            { x: 0.25, y: 0.14 }, { x: 0.50, y: 0.16 }, { x: 0.75, y: 0.14 },
            { x: 0.35, y: 0.07 }, { x: 0.65, y: 0.07 },
          ],
          '1-3-1': [
            { x: 0.50, y: 0.18 }, { x: 0.22, y: 0.12 }, { x: 0.78, y: 0.12 },
            { x: 0.50, y: 0.12 }, { x: 0.50, y: 0.04 },
          ],
          'man-to-man': [
            { x: 0.50, y: 0.20 }, { x: 0.18, y: 0.30 }, { x: 0.82, y: 0.30 },
            { x: 0.13, y: 0.42 }, { x: 0.87, y: 0.42 },
          ],
          'box-one': [
            { x: 0.50, y: 0.20 },
            { x: 0.35, y: 0.12 }, { x: 0.65, y: 0.12 },
            { x: 0.35, y: 0.05 }, { x: 0.65, y: 0.05 },
          ],
        },
      };
      return formations[state.courtType][name] || formations[state.courtType]['man-to-man'];
    }

    function drawPlayers() {
      const ctx = interCtx;
      ctx.clearRect(0, 0, interactionCanvas.width, interactionCanvas.height);

      state.players.forEach(player => {
        if (player.team === 'ball') {
          drawBasketball(ctx, player.x, player.y);
          return;
        }

        const r = CONFIG.player.radius * state.pxPerFt / 10;

        ctx.beginPath();
        ctx.arc(player.x, player.y, r, 0, Math.PI * 2);
        ctx.fillStyle = player.team === 'offense' ? CONFIG.player.offenseColor : CONFIG.player.defenseColor;
        ctx.fill();
        ctx.strokeStyle = CONFIG.player.strokeColor;
        ctx.lineWidth = CONFIG.player.strokeWidth * state.pxPerFt / 10;
        ctx.stroke();

        if (player.label) {
          ctx.fillStyle = '#ffffff';
          ctx.font = `bold ${CONFIG.player.fontSize * state.pxPerFt / 10}px sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(player.label, player.x, player.y + 0.5);
        }
      });
    }

    function drawBasketball(ctx, x, y) {
      const r = CONFIG.ballRadius * state.pxPerFt / 10;

      // Orange ball
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fillStyle = '#f97316';
      ctx.fill();
      ctx.strokeStyle = '#7c2d12';
      ctx.lineWidth = 1.2 * state.pxPerFt / 10;
      ctx.stroke();

      // Ball lines
      ctx.strokeStyle = '#7c2d1280';
      ctx.lineWidth = 0.8 * state.pxPerFt / 10;

      // Horizontal line
      ctx.beginPath();
      ctx.moveTo(x - r, y);
      ctx.lineTo(x + r, y);
      ctx.stroke();

      // Vertical line
      ctx.beginPath();
      ctx.moveTo(x, y - r);
      ctx.lineTo(x, y + r);
      ctx.stroke();

      // Curved lines
      ctx.beginPath();
      ctx.arc(x - r * 0.3, y, r * 0.75, -Math.PI * 0.4, Math.PI * 0.4);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(x + r * 0.3, y, r * 0.75, Math.PI - Math.PI * 0.4, Math.PI + Math.PI * 0.4);
      ctx.stroke();
    }

    // ===== Drawing System =====
    function redrawDrawings() {
      const ctx = drawCtx;
      ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
      state.drawings.forEach(d => drawSingleDrawing(ctx, d));
    }

    function drawSingleDrawing(ctx, d) {
      const s = state.pxPerFt / 10;
      if (d.type === 'path') {
        if (d.points.length < 2) return;
        ctx.beginPath();
        ctx.strokeStyle = d.color;
        ctx.lineWidth = d.width * s;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.setLineDash([]);
        ctx.moveTo(d.points[0].x, d.points[0].y);
        for (let i = 1; i < d.points.length; i++) {
          ctx.lineTo(d.points[i].x, d.points[i].y);
        }
        ctx.stroke();
      } else if (d.type === 'arrow') {
        drawArrowLine(ctx, d.from, d.to, d.color, d.width * s, false);
      } else if (d.type === 'dashed') {
        drawArrowLine(ctx, d.from, d.to, d.color, d.width * s, true);
      } else if (d.type === 'screen') {
        drawScreenSymbol(ctx, d.x, d.y, d.angle, d.color, d.width * s);
      } else if (d.type === 'zigzag') {
        drawZigzagLine(ctx, d.from, d.to, d.color, d.width * s);
      } else if (d.type === 'text') {
        ctx.fillStyle = d.color;
        ctx.font = `bold ${14 * s}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(d.text, d.x, d.y);
      }
    }

    function drawArrowLine(ctx, from, to, color, width, dashed) {
      const dx = to.x - from.x;
      const dy = to.y - from.y;
      const angle = Math.atan2(dy, dx);
      const headLen = 12 * state.pxPerFt / 10;

      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.lineCap = 'round';
      ctx.setLineDash(dashed ? [7 * state.pxPerFt / 10, 5 * state.pxPerFt / 10] : []);
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.stroke();

      ctx.setLineDash([]);
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.moveTo(to.x, to.y);
      ctx.lineTo(to.x - headLen * Math.cos(angle - Math.PI / 6), to.y - headLen * Math.sin(angle - Math.PI / 6));
      ctx.lineTo(to.x - headLen * Math.cos(angle + Math.PI / 6), to.y - headLen * Math.sin(angle + Math.PI / 6));
      ctx.closePath();
      ctx.fill();
    }

    function drawScreenSymbol(ctx, x, y, angle, color, width) {
      const len = 14 * state.pxPerFt / 10;
      const perpAngle = angle + Math.PI / 2;

      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = Math.max(width * 2, 5 * state.pxPerFt / 10);
      ctx.lineCap = 'round';
      ctx.setLineDash([]);
      ctx.moveTo(x - len * Math.cos(perpAngle), y - len * Math.sin(perpAngle));
      ctx.lineTo(x + len * Math.cos(perpAngle), y + len * Math.sin(perpAngle));
      ctx.stroke();
    }

    function drawZigzagLine(ctx, from, to, color, width) {
      const dx = to.x - from.x;
      const dy = to.y - from.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 5) return;

      const numZigs = Math.max(4, Math.round(dist / (12 * state.pxPerFt / 10)));
      const nx = -dy / dist;
      const ny = dx / dist;
      const amp = 6 * state.pxPerFt / 10;

      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.setLineDash([]);
      ctx.moveTo(from.x, from.y);

      for (let i = 1; i <= numZigs; i++) {
        const t = i / numZigs;
        const mx = from.x + dx * t;
        const my = from.y + dy * t;
        if (i < numZigs) {
          const side = (i % 2 === 1) ? 1 : -1;
          ctx.lineTo(mx + nx * amp * side, my + ny * amp * side);
        } else {
          ctx.lineTo(to.x, to.y);
        }
      }
      ctx.stroke();

      // Small arrowhead
      const angle = Math.atan2(dy, dx);
      const headLen = 8 * state.pxPerFt / 10;
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.moveTo(to.x, to.y);
      ctx.lineTo(to.x - headLen * Math.cos(angle - Math.PI / 6), to.y - headLen * Math.sin(angle - Math.PI / 6));
      ctx.lineTo(to.x - headLen * Math.cos(angle + Math.PI / 6), to.y - headLen * Math.sin(angle + Math.PI / 6));
      ctx.closePath();
      ctx.fill();
    }

    // ===== Undo/Redo =====
    function saveState() {
      state.undoStack.push({
        players: JSON.parse(JSON.stringify(state.players)),
        drawings: JSON.parse(JSON.stringify(state.drawings)),
      });
      state.redoStack = [];
      if (state.undoStack.length > 50) state.undoStack.shift();
    }

    function undo() {
      if (state.undoStack.length === 0) return;
      state.redoStack.push({
        players: JSON.parse(JSON.stringify(state.players)),
        drawings: JSON.parse(JSON.stringify(state.drawings)),
      });
      const prev = state.undoStack.pop();
      state.players = prev.players;
      state.drawings = prev.drawings;
      redrawDrawings();
      drawPlayers();
    }

    function redo() {
      if (state.redoStack.length === 0) return;
      state.undoStack.push({
        players: JSON.parse(JSON.stringify(state.players)),
        drawings: JSON.parse(JSON.stringify(state.drawings)),
      });
      const next = state.redoStack.pop();
      state.players = next.players;
      state.drawings = next.drawings;
      redrawDrawings();
      drawPlayers();
    }

    // ===== Formations =====
    function applyFormation(name) {
      saveState();
      const w = courtCanvas.width;
      const h = courtCanvas.height;

      // Offense stays 5-out
      const offPos = get5OutPositions();
      const defPos = getDefenseFormation(name);
      const newPlayers = [];

      offPos.forEach((p, i) => {
        newPlayers.push({ x: p.x * w, y: p.y * h, label: POSITIONS[i], team: 'offense' });
      });
      defPos.forEach((p, i) => {
        newPlayers.push({ x: p.x * w, y: p.y * h, label: POSITIONS[i], team: 'defense' });
      });

      // Ball near PG
      const ballR = CONFIG.ballRadius * state.pxPerFt / 10;
      const playerR = CONFIG.player.radius * state.pxPerFt / 10;
      newPlayers.push({
        x: newPlayers[0].x + playerR + ballR + 2,
        y: newPlayers[0].y,
        label: '', team: 'ball',
      });

      state.players = newPlayers;
      drawPlayers();
    }

    // ===== Event Handlers =====
    function getCanvasPos(e) {
      const rect = interactionCanvas.getBoundingClientRect();
      const src = e.touches ? e.touches[0] || e.changedTouches[0] : e;
      return { x: src.clientX - rect.left, y: src.clientY - rect.top };
    }

    function findPlayerAt(pos) {
      const r = CONFIG.player.radius * state.pxPerFt / 10;
      for (let i = state.players.length - 1; i >= 0; i--) {
        const p = state.players[i];
        const pr = p.team === 'ball' ? CONFIG.ballRadius * state.pxPerFt / 10 : r;
        const dx = pos.x - p.x;
        const dy = pos.y - p.y;
        if (dx * dx + dy * dy <= (pr + 4) * (pr + 4)) return i;
      }
      return -1;
    }

    function onPointerDown(e) {
      e.preventDefault();
      const pos = getCanvasPos(e);

      if (state.currentTool === 'move') {
        const idx = findPlayerAt(pos);
        if (idx >= 0) {
          saveState();
          state.isDragging = true;
          state.dragPlayer = idx;
          state.dragOffset = { x: pos.x - state.players[idx].x, y: pos.y - state.players[idx].y };
          interactionCanvas.style.cursor = 'grabbing';
        }
      } else if (state.currentTool === 'draw') {
        saveState();
        state.isDrawing = true;
        state.currentPath = [{ x: pos.x, y: pos.y }];
      } else if (state.currentTool === 'arrow' || state.currentTool === 'dashed' || state.currentTool === 'zigzag') {
        saveState();
        state.isDrawing = true;
        state.arrowStart = { x: pos.x, y: pos.y };
      } else if (state.currentTool === 'screen') {
        saveState();
        state.isDrawing = true;
        state.arrowStart = { x: pos.x, y: pos.y };
      } else if (state.currentTool === 'eraser') {
        eraseAt(pos);
      } else if (state.currentTool === 'text') {
        const text = prompt('Enter text:');
        if (text) {
          saveState();
          state.drawings.push({ type: 'text', x: pos.x, y: pos.y, text, color: state.penColor });
          redrawDrawings();
        }
      }
    }

    function onPointerMove(e) {
      e.preventDefault();
      const pos = getCanvasPos(e);
      const s = state.pxPerFt / 10;

      if (state.currentTool === 'move') {
        if (state.isDragging && state.dragPlayer !== null) {
          state.players[state.dragPlayer].x = pos.x - state.dragOffset.x;
          state.players[state.dragPlayer].y = pos.y - state.dragOffset.y;
          drawPlayers();
        } else {
          interactionCanvas.style.cursor = findPlayerAt(pos) >= 0 ? 'grab' : 'default';
        }
      } else if (state.currentTool === 'draw' && state.isDrawing) {
        state.currentPath.push(pos);
        redrawDrawings();
        const ctx = drawCtx;
        ctx.beginPath();
        ctx.strokeStyle = state.penColor;
        ctx.lineWidth = state.lineWidth * s;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.setLineDash([]);
        ctx.moveTo(state.currentPath[0].x, state.currentPath[0].y);
        for (let i = 1; i < state.currentPath.length; i++) {
          ctx.lineTo(state.currentPath[i].x, state.currentPath[i].y);
        }
        ctx.stroke();
      } else if ((state.currentTool === 'arrow' || state.currentTool === 'dashed') && state.isDrawing) {
        redrawDrawings();
        drawArrowLine(drawCtx, state.arrowStart, pos, state.penColor, state.lineWidth * s, state.currentTool === 'dashed');
      } else if (state.currentTool === 'zigzag' && state.isDrawing) {
        redrawDrawings();
        drawZigzagLine(drawCtx, state.arrowStart, pos, state.penColor, state.lineWidth * s);
      } else if (state.currentTool === 'screen' && state.isDrawing) {
        redrawDrawings();
        const dx = pos.x - state.arrowStart.x;
        const dy = pos.y - state.arrowStart.y;
        const angle = Math.atan2(dy, dx);
        drawScreenSymbol(drawCtx, state.arrowStart.x, state.arrowStart.y, angle, state.penColor, state.lineWidth * s);
      } else if (state.currentTool === 'eraser' && (e.buttons > 0 || e.touches)) {
        eraseAt(pos);
      }
    }

    function onPointerUp(e) {
      const s = state.pxPerFt / 10;

      if (state.currentTool === 'move' && state.isDragging) {
        state.isDragging = false;
        state.dragPlayer = null;
        interactionCanvas.style.cursor = 'default';
      } else if (state.currentTool === 'draw' && state.isDrawing) {
        state.isDrawing = false;
        if (state.currentPath.length > 1) {
          state.drawings.push({ type: 'path', points: [...state.currentPath], color: state.penColor, width: state.lineWidth });
        }
        state.currentPath = [];
        redrawDrawings();
      } else if ((state.currentTool === 'arrow' || state.currentTool === 'dashed') && state.isDrawing) {
        state.isDrawing = false;
        if (state.arrowStart) {
          const pos = getCanvasPos(e);
          const dx = pos.x - state.arrowStart.x;
          const dy = pos.y - state.arrowStart.y;
          if (Math.sqrt(dx * dx + dy * dy) > 10) {
            state.drawings.push({
              type: state.currentTool === 'dashed' ? 'dashed' : 'arrow',
              from: { ...state.arrowStart }, to: pos,
              color: state.penColor, width: state.lineWidth,
            });
          }
        }
        state.arrowStart = null;
        redrawDrawings();
      } else if (state.currentTool === 'zigzag' && state.isDrawing) {
        state.isDrawing = false;
        if (state.arrowStart) {
          const pos = getCanvasPos(e);
          const dx = pos.x - state.arrowStart.x;
          const dy = pos.y - state.arrowStart.y;
          if (Math.sqrt(dx * dx + dy * dy) > 10) {
            state.drawings.push({
              type: 'zigzag', from: { ...state.arrowStart }, to: pos,
              color: state.penColor, width: state.lineWidth,
            });
          }
        }
        state.arrowStart = null;
        redrawDrawings();
      } else if (state.currentTool === 'screen' && state.isDrawing) {
        state.isDrawing = false;
        if (state.arrowStart) {
          const pos = getCanvasPos(e);
          const dx = pos.x - state.arrowStart.x;
          const dy = pos.y - state.arrowStart.y;
          const angle = Math.atan2(dy, dx);
          state.drawings.push({
            type: 'screen', x: state.arrowStart.x, y: state.arrowStart.y, angle,
            color: state.penColor, width: state.lineWidth,
          });
        }
        state.arrowStart = null;
        redrawDrawings();
      }
    }

    function eraseAt(pos) {
      const eraserRadius = 18 * state.pxPerFt / 10;
      let erased = false;
      for (let i = state.drawings.length - 1; i >= 0; i--) {
        const d = state.drawings[i];
        let hit = false;
        if (d.type === 'path') {
          for (const pt of d.points) {
            if ((pt.x - pos.x) ** 2 + (pt.y - pos.y) ** 2 < eraserRadius ** 2) { hit = true; break; }
          }
        } else if (d.type === 'arrow' || d.type === 'dashed' || d.type === 'zigzag') {
          hit = distToSegment(pos, d.from, d.to) < eraserRadius;
        } else if (d.type === 'screen') {
          hit = (d.x - pos.x) ** 2 + (d.y - pos.y) ** 2 < eraserRadius ** 2 * 2;
        } else if (d.type === 'text') {
          hit = (d.x - pos.x) ** 2 + (d.y - pos.y) ** 2 < eraserRadius ** 2 * 2;
        }
        if (hit) {
          if (!erased) saveState();
          state.drawings.splice(i, 1);
          erased = true;
        }
      }
      if (erased) redrawDrawings();
    }

    function distToSegment(p, v, w) {
      const l2 = (w.x - v.x) ** 2 + (w.y - v.y) ** 2;
      if (l2 === 0) return Math.sqrt((p.x - v.x) ** 2 + (p.y - v.y) ** 2);
      let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
      t = Math.max(0, Math.min(1, t));
      return Math.sqrt((p.x - (v.x + t * (w.x - v.x))) ** 2 + (p.y - (v.y + t * (w.y - v.y))) ** 2);
    }

    // ===== Export =====
    function exportPNG() {
      const c = document.createElement('canvas');
      c.width = courtCanvas.width;
      c.height = courtCanvas.height;
      const ctx = c.getContext('2d');
      ctx.drawImage(courtCanvas, 0, 0);
      ctx.drawImage(drawCanvas, 0, 0);
      ctx.drawImage(interactionCanvas, 0, 0);
      const link = document.createElement('a');
      link.download = 'basketball-strategy.png';
      link.href = c.toDataURL('image/png');
      link.click();
    }

    // ===== Tool Selection Helper =====
    function selectTool(tool) {
      state.currentTool = tool;
      // Desktop buttons
      document.querySelectorAll('.tool-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.tool === tool);
      });
      // Mobile buttons
      document.querySelectorAll('#mobileTools .mobile-tool-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.tool === tool);
      });
      // Cursor
      if (tool === 'move') interactionCanvas.style.cursor = 'default';
      else if (tool === 'text') interactionCanvas.style.cursor = 'text';
      else interactionCanvas.style.cursor = 'crosshair';
    }

    function selectCourtType(type) {
      state.courtType = type;
      state.drawings = [];
      state.undoStack = [];
      state.redoStack = [];
      // Desktop buttons
      document.querySelectorAll('.court-type-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.court === type);
      });
      // Mobile buttons
      document.querySelectorAll('[data-court-m]').forEach(b => {
        b.classList.toggle('active', b.dataset.courtM === type);
      });
      createDefaultPlayers();
      resizeCanvases();
    }

    // ===== UI Event Bindings =====
    // Desktop tool buttons
    document.querySelectorAll('.tool-btn').forEach(btn => {
      btn.addEventListener('click', () => selectTool(btn.dataset.tool));
    });

    // Desktop court type
    document.querySelectorAll('.court-type-btn').forEach(btn => {
      btn.addEventListener('click', () => selectCourtType(btn.dataset.court));
    });

    // Color swatches
    document.querySelectorAll('.color-swatch').forEach(swatch => {
      swatch.addEventListener('click', () => {
        document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
        swatch.classList.add('active');
        state.penColor = swatch.dataset.color;
      });
    });

    // Line width
    document.getElementById('lineWidth').addEventListener('input', e => {
      state.lineWidth = parseInt(e.target.value);
    });

    // Desktop formations
    document.querySelectorAll('[data-formation]').forEach(btn => {
      btn.addEventListener('click', () => applyFormation(btn.dataset.formation));
    });

    // Undo/Redo desktop
    document.getElementById('undoBtn').addEventListener('click', undo);
    document.getElementById('redoBtn').addEventListener('click', redo);

    // Keyboard shortcuts
    document.addEventListener('keydown', e => {
      if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); }
      if (e.ctrlKey && e.key === 'y') { e.preventDefault(); redo(); }
    });

    // Clear / Reset desktop
    document.getElementById('clearDrawings').addEventListener('click', () => {
      saveState();
      state.drawings = [];
      redrawDrawings();
    });

    document.getElementById('resetAll').addEventListener('click', () => {
      if (confirm('Reset all?')) {
        state.drawings = [];
        state.undoStack = [];
        state.redoStack = [];
        createDefaultPlayers();
        redrawDrawings();
        drawPlayers();
      }
    });

    document.getElementById('exportBtn').addEventListener('click', exportPNG);

    // ===== Mobile toolbar bindings =====
    document.querySelectorAll('#mobileTools .mobile-tool-btn[data-tool]').forEach(btn => {
      btn.addEventListener('click', () => selectTool(btn.dataset.tool));
    });

    document.getElementById('mobileMoreBtn').addEventListener('click', () => {
      document.getElementById('mobilePanel').classList.toggle('open');
    });

    document.querySelectorAll('[data-court-m]').forEach(btn => {
      btn.addEventListener('click', () => {
        selectCourtType(btn.dataset.courtM);
        document.getElementById('mobilePanel').classList.remove('open');
      });
    });

    document.querySelectorAll('[data-formation-m]').forEach(btn => {
      btn.addEventListener('click', () => {
        applyFormation(btn.dataset.formationM);
        document.getElementById('mobilePanel').classList.remove('open');
      });
    });

    document.getElementById('mobileUndo').addEventListener('click', undo);
    document.getElementById('mobileRedo').addEventListener('click', redo);
    document.getElementById('mobileClear').addEventListener('click', () => {
      saveState(); state.drawings = []; redrawDrawings();
    });
    document.getElementById('mobileReset').addEventListener('click', () => {
      if (confirm('Reset all?')) {
        state.drawings = []; state.undoStack = []; state.redoStack = [];
        createDefaultPlayers(); redrawDrawings(); drawPlayers();
      }
    });
    document.getElementById('mobileExport').addEventListener('click', exportPNG);

    // ===== Canvas events =====
    interactionCanvas.addEventListener('mousedown', onPointerDown);
    interactionCanvas.addEventListener('mousemove', onPointerMove);
    interactionCanvas.addEventListener('mouseup', onPointerUp);
    interactionCanvas.addEventListener('mouseleave', onPointerUp);
    interactionCanvas.addEventListener('touchstart', onPointerDown, { passive: false });
    interactionCanvas.addEventListener('touchmove', onPointerMove, { passive: false });
    interactionCanvas.addEventListener('touchend', onPointerUp);

    window.addEventListener('resize', resizeCanvases);

    // ===== Initialize =====
    createDefaultPlayers();
    resizeCanvases();
  </script>
</body>
</html>
